<h1>Projeto 02 - Blog Pessoal - Teste de Software - xUnit - Teste da Camada User</h1>



Vamos implementar os M√©todos de Teste da aplica√ß√£o:

<br />

<h2>üë£ Passo 01 - Criar a Classe UserControllerTest no Projeto Blog Pessoal Test</h2>



Dentro do projeto **blogpessoaltest**, vamos criar a pasta **Controller**:

1. No lado direito superior, na Guia **Gerenciador de Solu√ß√µes**, clique com o bot√£o direito do mouse sobre o projeto  **blogpessoaltest** e clique na op√ß√£o **Adicionar ü°™ Nova Pasta**
2. Digite o nome da pasta (**Controller**), com a primeira letra mai√∫scula, seguindo o padr√£o do C# e pressione **enter** para concluir. O Gerenciador de Solu√ß√µes da aplica√ß√£o ficar√° semelhante a imagem abaixo:

Vamos criar a **Classe UserControllerTest** na pasta **Controller**:

1. Clique com o bot√£o direito do mouse sobre a **pasta Controller**, do projeto **blogpessoaltest** e na sequ√™ncia, clique na op√ß√£o **Adicionar ü°™ Classe**.
2. No item **Nome**, digite o nome da Classe (**UserControllerTest**)

Antes de come√ßar a implementar os M√©todos de teste, vamos criar as Inje√ß√µes de Depend√™ncia, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/sTNoIJZ.png" title="source: imgur.com" /></div>

**Linhas 01 a 10:** Faz a importa√ß√£o dos Pacotes e Namespaces necess√°rios.

**Linha 13:** Foi criada a Classe **UserControllerTest** como uma Heran√ßa da Classe **IClassFixture**, que recebe como par√¢metro a Classe `WebAppFactory`, que ser√° utilizada para executar os testes E2E. 

As Classe de Testes **UserControllerTest** implementar√° a interface **IClassFixture**, que utilizar√° o contexto de testes, que utiliza um Banco de dados em mem√≥ria para simular o Banco de dados da aplica√ß√£o e o Servi√ßo Fake Token JWT, que simula a gera√ß√£o de Tokens JWT.

**Linha 15:** Cria um Objeto da Classe **WebAppFactory**, que fornece o ambiente de testes da aplica√ß√£o.

**Linha 16:** Cria um Objeto da Classe **HttpClient**, que fornece m√©todos de teste, que geram Requisi√ß√µes HTTP.

Os Objetos **WebAppFactory e HttpClient** ser√£o injetados na Classe UserControllerTest.

**Linha 18:**  Cria um atributo do tipo **dynamic**, somente leitura, chamado **Token**, que ser√° utilizado para receber o Fake Token JWT. 

> O tipo **dynamic** √© um tipo de dado est√°tico (static), que √© definido pela palavra reservada **dynamic**, que num primeiro momento esta vari√°vel pode assumir qualquer tipo de dado. Em tempo de compila√ß√£o o tipo dynamic assume um tipo de dado. Mesmo sendo um tipo est√°tico, a declara√ß√£o **dynamic** faz com que o  compilador n√£o realize as valida√ß√µes est√°ticas, logo as opera√ß√µes somente ser√£o avaliadas em tempo de execu√ß√£o.
>
> No tipo dynamic a informa√ß√£o √© conhecida somente em tempo de execu√ß√£o e pode ser aplicado a propriedades, retorno de m√©todos, par√¢metros, objetos, enfim a TUDO.

**Linha 19:**  Cria um atributo do tipo string, chamado **Id**, que ser√° utilizado nos testes.

**Linhas 21 a 27:** Cria o M√©todo Construtor, que recebe o par√¢metro chamado **factory**, do tipo `WebAppFactory<Program>`.

**Linha 25:** Atribui ao Objeto **_client** uma inst√¢ncia da Classe **HttpClient**, criando uma Inje√ß√£o de Depend√™ncia. A partir desta Inje√ß√£o, construiremos as Requisi√ß√µes para testar a aplica√ß√£o.

**Linha 26:** Atribui ao Atributo **token** o resutado do M√©todo **GetToken()**, respons√°vel por criar o Fake Tokens JWT, que ser√° utilizado para testar os endpoints protegidos.

<br />

<h3>M√©todo Auxiliar - GetToken</h3>

<br />

<div align="center"><img src="https://i.imgur.com/sOLMR5A.png" title="source: imgur.com" /></div>

**Linha 31:** cria um Objeto do tipo dynamic, chamado **data**, como um Objeto da Classe **ExpandoObject**, cujos membros podem ser adicionados e removidos em tempo de execu√ß√£o dinamicamente.

**Linha 32:** insere o usu√°rio (e-mail), que ser√° utilizado para gerar o Fake Token JWT, na propriedade **sub (subject)** do Objeto data.

**Linha 33:** Retorna Objeto data.

<br />

<h3>M√©todo 01 - Deve Criar Novo Usu√°rio</h3>

<br />

<div align="center"><img src="https://i.imgur.com/KPenlkG.png" title="source: imgur.com" /></div>

**Linha 36:** Insere a anota√ß√£o **[Fact, Order(1)]** acima do M√©todo de testes, indicando que ser√° um teste do tipo **Fact** e a ordem em que ele ser√° ser√° executado.

> **Fact** √© um tipo de teste que afirma que o m√©todo que escrevemos deve ser executado e que n√£o enviaremos nenhum par√¢metro para o m√©todo de teste.

**Linha 37:** Cria o M√©todo que executar√° o Teste **Deve Criar Novo Usuario**.

**Linha 39:** Define os dados do Objeto Usuario que ser√° enviado no Corpo da Requisi√ß√£o, atrav√©s do M√©todo **PostAsync()**. Nesta etapa, o processo √© equivalente ao que o Insomnia faz em uma requisi√ß√£o do tipo **POST**: Transforma os atributos num objeto da Classe Usuario, que ser√° enviado no corpo da requisi√ß√£o (Request Body). Observe que o Objeto foi criado dentro de uma **Collection Dictionary**, chamada **novoUsuario**.

**Linha 47:** Cria um Objeto chamado **usuarioJson**, que receber√° o Objeto Dictionary convertido para o formato JSON.

**Linha 49:** Cria um Objeto chamado **corpoRequisicao**, que receber√° o Objeto **usuarioJson** e criar√° o Corpo da Requisi√ß√£o, que ser√° enviado na Reaquisi√ß√£o **POST**.

**Linha 51:** Foi criado um Objeto chamado **resposta**, que receber√° a Resposta da Requisi√ß√£o, enviada pelo M√©todo **PostAsync()**. Observe que foram passados como argumentos do M√©todo **PostAsync()** o endpoint do M√©todo POST  (**/usuarios/cadastrar**) e o Objeto **corpoRequisicao**.

**Linha 53:** Gera uma exce√ß√£o caso a resposta HTTP n√£o seja do tipo Sucess (HTTP Status Code 200 - 299).

**Linha 55:** Atrav√©s do m√©todo <b>Should().Be()</b>, checaremos se a Resposta HTTP da Requisi√ß√£o (Response), √© a resposta esperada (**CREATED ü°™ 201**). Caso o HTTP Status da Resposta da Requisi√ß√£o seja 201, o **Teste Passa**. Caso seja outro HTTP Status, o **Teste Falha**.

<br />

<h3>M√©todo 02 - N√£o Deve Criar Usu√°rio Duplicado</h3>

<br />

<div align="center"><img src="https://i.imgur.com/JS9Mbah.png" title="source: imgur.com" /></div>

**Linha 59:** Insere a anota√ß√£o **[Fact, Order(2)]** acima do M√©todo de testes, indicando que ser√° um teste do tipo **Fact** e a ordem em que ele ser√° ser√° executado.

**Linha 60:** Cria o M√©todo que executar√° o Teste **Nao Deve Criar Usuario Duplicado**.

**Linha 61:** Define os dados do Objeto Usuario que ser√° enviado no Corpo da Requisi√ß√£o, atrav√©s do M√©todo **PostAsync()**. Nesta etapa, o processo √© equivalente ao que o Insomnia faz em uma requisi√ß√£o do tipo **POST**: Transforma os atributos num objeto da Classe Usuario, que ser√° enviado no corpo da requisi√ß√£o (Request Body). Observe que o Objeto foi criado dentro de uma **Collection Dictionary**, chamada **novoUsuario**.

**Linha 70:** Cria um Objeto chamado **usuarioJson**, que receber√° o Objeto Dictionary convertido para o formato JSON.

**Linha 72:** Cria um Objeto chamado **corpoRequisicao**, que receber√° o Objeto **usuarioJson** e criar√° o Corpo da Requisi√ß√£o, que ser√° enviado na Reaquisi√ß√£o **POST**.

**Linha 74:** Envia a Requisi√ß√£o **POST**, atrav√©s do M√©todo **PostAsync()**. Observe que foram passados como argumentos do M√©todo **PostAsync()** o endpoint do M√©todo POST  (**/usuarios/cadastrar**) e o Objeto **corpoRequisicao**.

**Linha 78:** Envia a Requisi√ß√£o **POST** novamente para simular a duplica√ß√£o de dados. Para receber a Resposta do reenvio da Requisi√ß√£o **POST** foi criado um Objeto chamado **resposta**.

**Linha 80:** Atrav√©s do m√©todo <b>Should().Be()</b>, checaremos se a Resposta HTTP da Requisi√ß√£o (Response), √© a resposta esperada (**BAD REQUEST ü°™ 400**). Caso o HTTP Status da Resposta da Requisi√ß√£o seja 400, o **Teste Passa**. Caso seja outro HTTP Status, o **Teste Falha**.

<br />

| <img src="https://i.imgur.com/nSpXEZ0.png" title="source: imgur.com" width="250px"/> | <p align="justify"> Observe que neste m√©todo temos o objetivo de testar o Erro! (Usu√°rio Duplicado) e n√£o a persist√™ncia dos dados. Por este motivo enviamos o mesmo objeto que foi enviado na primeira Requisi√ß√£o e verificaremos se o aplicativo rejeita a persist√™ncia do mesmo objeto pela segunda vez (BAD REQUEST). </p> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h3>M√©todo 03 - Deve Atualizar Usu√°rio</h3>

<br />

<div align="center"><img src="https://i.imgur.com/y9IYKL9.png" title="source: imgur.com" /></div>

**Linha 83:** Insere a anota√ß√£o **[Fact, Order(3)]** acima do M√©todo de testes, indicando que ser√° um teste do tipo **Fact** e a ordem em que ele ser√° ser√° executado.

**Linha 84:** Cria o M√©todo que executar√° o Teste **Deve Atualizar Usuario**.

**Linha 87:** Define os dados do Objeto Usuario que ser√° enviado no Corpo da Requisi√ß√£o, atrav√©s do M√©todo **PostAsync()**. Nesta etapa, o processo √© equivalente ao que o Insomnia faz em uma requisi√ß√£o do tipo **POST**: Transforma os atributos num objeto da Classe Usuario, que ser√° enviado no corpo da requisi√ß√£o (Request Body). Observe que o Objeto foi criado dentro de uma **Collection Dictionary**, chamada **novoUsuario**.

**Linha 95:** Cria um Objeto chamado **postJson**, que receber√° o Objeto Dictionary convertido para o formato JSON.

**Linha 97:** Cria um Objeto chamado **corpoRequisicaoPost**, que receber√° o Objeto **usuarioJson** e criar√° o Corpo da Requisi√ß√£o, que ser√° enviado na Reaquisi√ß√£o **POST**.

**Linha 99:** Foi criado um Objeto chamado **respostaPost**, que receber√° a Resposta da Requisi√ß√£o, enviada pelo M√©todo **PostAsync()**. Observe que foram passados como argumentos do M√©todo **PostAsync()** o endpoint do M√©todo POST  (**/usuarios/cadastrar**) e o Objeto **corpoRequisicaoPost**.

**Linha 101:** Foi criado um Objeto chamado **corpoRespostaPost**, que receber√° o Corpo da Resposta da Requisi√ß√£o, enviada pelo M√©todo **PostAsync()**, no formato JSON.

**Linhas 103 a 106:** Verifica se o Objeto **corpoRespostaPost** n√£o √© nulo. Se esta condi√ß√£o for verdadeira, guardaremos o atributo **Id** do Objeto persistido no atributo **Id** da Classe **UserControllerTest**.

**Linha 110:** Define os dados atualizados do Objeto Usuario que ser√° enviado no Corpo da Requisi√ß√£o, incluindo o **Id**, atrav√©s do M√©todo **PutAsync()**. Nesta etapa, o processo √© equivalente ao que o Insomnia faz em uma requisi√ß√£o do tipo **PUT**: Transforma os atributos num objeto da Classe Usuario, que ser√° enviado no corpo da requisi√ß√£o (Request Body). Observe que o Objeto foi criado dentro de uma **Collection Dictionary**, chamada **atualizarUsuario**.

**Linha 119:** Cria um Objeto chamado **updateJson**, que receber√° o Objeto Dictionary convertido para o formato JSON.

**Linha 121:** Cria um Objeto chamado **corpoRequisicaoUpdate**, que receber√° o Objeto **upadateJson** e criar√° o Corpo da Requisi√ß√£o, que ser√° enviado na Reaquisi√ß√£o **PUT**.

**Linha 123:** Como o endpoint (**/usuarios/atualizar**) est√° protegido pelo **Token JWT**, precisamos enviar o token de um usu√°rio v√°lido no cabe√ßalho da Requisi√ß√£o, atrav√©s do M√©todo **SetFakeBearerToken((object)token)**. Observe que foi passado como argumento do M√©todo **SetFakeBearerToken()** o atributo **token**, do tipo dynamic, convertido em um Objeto gen√©rico. Atrav√©s deste Objeto customizado, o Pacote Fake Token consegue validar o Fake Token enviado no cabe√ßalho da Requisi√ß√£o.

**Linha 125:** Foi criado um Objeto chamado **respostaPut**, que receber√° o resultado da Requisi√ß√£o, enviada pelo M√©todo **PutAsync()**. Observe que foram passados como argumentos do M√©todo **PutAsync()** o endpoint do M√©todo PUT  (**/usuarios/atualizar**) e o Objeto **corpoRequisicaoUpdate**.

**Linha 127:** Atrav√©s do m√©todo <b>Should().Be()</b>, checaremos se a Resposta HTTP da Requisi√ß√£o (Response), √© a resposta esperada (**OK ü°™ 200**). Caso o HTTP Status da Resposta da Requisi√ß√£o seja 200, o **Teste Passa**. Caso seja outro HTTP Status, o **Teste Falha**.

<br />

<h3>M√©todo 04 - Deve Listar todos os Usu√°rios</h3>

<br />

<div align="center"><img src="https://i.imgur.com/mCzD3eG.png" title="source: imgur.com" /></div>

**Linha 130:** Insere a anota√ß√£o **[Fact, Order(4)]** acima do M√©todo de testes, indicando que ser√° um teste do tipo **Fact** e a ordem em que ele ser√° ser√° executado.

**Linha 131:** Cria o M√©todo que executar√° o Teste **Deve Listar Todos Os Usuarios**.

**Linha 133:** Como o endpoint (**/usuarios/all**) est√° protegido pelo **Token JWT**, precisamos enviar o token de um usu√°rio v√°lido no cabe√ßalho da Requisi√ß√£o, atrav√©s do M√©todo **SetFakeBearerToken((object)token)**. Observe que foi passado como argumento do M√©todo **SetFakeBearerToken()** o atributo **token**, do tipo dynamic, convertido em um Objeto gen√©rico. Atrav√©s deste Objeto customizado, o Pacote Fake Token consegue validar o Fake Token enviado no cabe√ßalho da Requisi√ß√£o.

**Linha 135:** Foi criado um Objeto chamado **resposta**, que receber√° o resultado da Requisi√ß√£o, enviada pelo M√©todo **GetAsync()**. Por se tratar de uma Requisi√ß√£o do tipo **GET** n√£o ser√° enviado nenhum Objeto no Corpo da Requisi√ß√£o, apenas o endpoint do M√©todo GET  (**/usuarios/all**).

**Linha 137:** Atrav√©s do m√©todo <b>Should().Be()</b>, checaremos se a Resposta HTTP da Requisi√ß√£o (Response), √© a resposta esperada (**OK ü°™ 200**). Caso o HTTP Status da Resposta da Requisi√ß√£o seja 200, o **Teste Passa**. Caso seja outro HTTP Status, o **Teste Falha**.

<br />

Abaixo voc√™ confere a vers√£o final da Classe **UserControllerTest**:

<br />

```c#
using blogpessoal.Model;
using blogpessoaltest.Factory;
using FluentAssertions;
using Newtonsoft.Json;
using System.Dynamic;
using System.Net;
using System.Net.Http.Json;
using System.Text;
using Xunit.Extensions.Ordering;

namespace blogpessoaltest.Controllers
{
    public class UserControllerTest : IClassFixture<WebAppFactory>
    {
        protected readonly WebAppFactory _factory;
        protected HttpClient _client;

        private readonly dynamic token;
        private string Id { get; set; } = string.Empty;

        public UserControllerTest(WebAppFactory factory)
        {
            _factory = factory;
            _client = factory.CreateClient();

            token = GetToken();
        }

        private static dynamic GetToken()
        {
            dynamic data = new ExpandoObject();
            data.sub = "root@root.com";
            return data;
        }

        [Fact, Order(1)]
        public async Task DeveCriarNovoUsuario()
        {
            var novoUsuario = new Dictionary<string, string>
            {
                { "nome", "Jo√£o" },
                { "usuario", "joao12@email.com.br" },
                { "senha", "12345678" },
                { "foto", "-" }
            };

            var usuarioJson = JsonConvert.SerializeObject(novoUsuario);

            var corpoRequisicao = new StringContent(usuarioJson, Encoding.UTF8, "application/json");

            var resposta = await _client.PostAsync("/usuarios/cadastrar", corpoRequisicao);

            resposta.EnsureSuccessStatusCode();

            resposta.StatusCode.Should().Be(HttpStatusCode.Created);

        }

        [Fact, Order(2)]
        public async Task NaoDeveCriarUsuarioDuplicado()
        {
            var novoUsuario = new Dictionary<string, string>
            {
                { "nome", "Juliana Andrews" },
                { "usuario", "juliana@email.com.br" },
                { "senha", "12345678" },
                { "foto", "-" }
            };

            var usuarioJson = JsonConvert.SerializeObject(novoUsuario);

            var corpoRequisicao = new StringContent(usuarioJson, Encoding.UTF8, "application/json");

            await _client.PostAsync("/usuarios/cadastrar", corpoRequisicao);

            //Enviar a segunda vez

            var resposta = await _client.PostAsync("/usuarios/cadastrar", corpoRequisicao);

            resposta.StatusCode.Should().Be(HttpStatusCode.BadRequest);
        }

        [Fact, Order(3)]
        public async Task DeveAtualizarUsuario()
        {
            // Criar Usu√°rio
            var novoUsuario = new Dictionary<string, string>
            {
                { "nome", "Paulo Antunes" },
                { "usuario", "paulo@email.com.br" },
                { "senha", "12345678" },
                { "foto", "-" }
            };

            var postJson = JsonConvert.SerializeObject(novoUsuario);

            var corpoRequisicaoPost = new StringContent(postJson, Encoding.UTF8, "application/json");

            var respostaPost = await _client.PostAsync("/usuarios/cadastrar", corpoRequisicaoPost);

            var corpoRespostaPost = await respostaPost.Content.ReadFromJsonAsync<User>();

            if (corpoRespostaPost is not null)
            {
                Id = corpoRespostaPost.Id.ToString();
            }

            //Atualizar Usu√°rio

            var atualizarUsuario = new Dictionary<string, string>
            {
                { "id", Id },
                { "nome", "Paulo Cesar Antunes" },
                { "usuario", "paulo_cesar@email.com.br" },
                { "senha", "12345678" },
                { "foto", "-" }
            };

            var updateJson = JsonConvert.SerializeObject(atualizarUsuario);

            var corpoRequisicaoUpdate = new StringContent(updateJson, Encoding.UTF8, "application/json");

            _client.SetFakeBearerToken((object)token);

            var respostaPut = await _client.PutAsync("/usuarios/atualizar", corpoRequisicaoUpdate);

            respostaPut.StatusCode.Should().Be(HttpStatusCode.OK);
        }

        [Fact, Order(4)]
        public async Task DeveListarTodosOsUsuarios()
        {
            _client.SetFakeBearerToken((object)token);

            var resposta = await _client.GetAsync("/usuarios/all");

            resposta.StatusCode.Should().Be(HttpStatusCode.OK);
            
        }
    }
}
```

<br />

<div align="left"><img src="https://i.imgur.com/vaJPP2L.png" title="source: imgur.com" width="4%"/> <a href="https://fluentassertions.com/basicassertions/" target="_blank"><b>Documenta√ß√£o: Asser√ß√µes B√°sicas</b></a></div>

<div align="left"><img src="https://i.imgur.com/FTXqbGV.jpg" title="source: imgur.com" width="4%"/> <a href="https://github.com/webmotions/fake-authentication-jwtbearer" target="_blank"><b>Site Oficial: Biblioteca Webmotions Fake Token JWT</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.dynamic.expandoobject?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Classe ExpandoObject</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.httpresponsemessage.ensuresuccessstatuscode?view=net-7.0" target="_blank"><b>Documenta√ß√£o: M√©todo EnsureSuccessStatusCode()</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.object?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Classe Object</b></a></div>

<br />

<h2>üë£ Passo 02 - Executando os Testes no Visual Studio</h2>



Chegou a hora de executar os testes:

1. No Menu **Teste**, clique na op√ß√£o **Executar Todos os Testes**.

<div align="center"><img src="https://i.imgur.com/bi5fDFe.png" title="source: imgur.com" /></div>

2. Ser√° aberta a Janela **Gerenciador de Testes**.
3. Aguarde a Execu√ß√£o dos Testes. Se o teste passou ser√° exibido um **check** na cor verde, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/EAwq8jr.png" title="source: imgur.com" /></div>

4. Se o teste falhou ser√° exibido um **X** na cor vermelha, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/WO3Mz8E.png" title="source: imgur.com" /></div>

5. Para Executar os testes novamente, voc√™ tem 2 op√ß√µes:

- No **Gerenciador de Testes**, clique no bot√£o **Executar Todos** <img src="https://i.imgur.com/nTWT0Vx.png" title="source: imgur.com" width="3%"/>, para executar todos os testes novamente.
- No **Gerenciador de Testes**, selecione o teste que voc√™ deseja executar e clique no bot√£o **Executar** <img src="https://i.imgur.com/SdZ9cYJ.png" title="source: imgur.com" width="3%"/>, para executar todos os testes novamente.

<br />

| <img src="https://i.imgur.com/L338M2G.png" title="source: imgur.com" width="100px"/> | **DESAFIO:** *Fa√ßa algumas altera√ß√µes nos dados dos Objetos e/ou escreva outros testes para praticar.* A melhor forma de aprender e compreender como funcionam os testes √© praticando! |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_aspnet_v7/tree/16_testes_xunit" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br />

<h2>‚úî Boas pr√°ticas</h2>

<br />

1. **Fa√ßa testes pequenos.**
2. **Fa√ßa testes r√°pidos:** Os testes devem ser simples e objetivos porqu√™ ser√£o executados o tempo todo.
3. **Fa√ßa testes determin√≠sticos:** O teste deve garantir o resultado.
4. **Utilize nomes auto descritivos:** A ideia √© que voc√™ entenda o que o teste faz sem precisar abri-lo.
6. **Insira poucas asser√ß√µes em cada teste:** O objetivo √© que um teste seja respons√°vel por apenas uma verifica√ß√£o.
7. **Sempre avalie os resultados dos seus testes.**

<br /> <br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
