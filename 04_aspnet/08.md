<h1>Projeto 02 - Blog Pessoal - Classes PostagemController e PostagemService - M√©todo Consultar todas as Postagens</h1>



O que veremos por aqui:

1. Implementar o m√©todo GetAll() na Classe PostagemService
2. Criar a Classe PostagemController
3. Criar o m√©todo GetAll() para listar todas as Postagens na Classe PostagemController
4. Testar o M√©todo findAll() no Insomnia



<h2>1. O Recurso Postagem</h2>



Na etapa anterior, come√ßamos a construir o **Recurso Postagem**, a partir da **Classe Entidade (Model) Postagem**, onde implementamos todos os atributos do recurso Postagem e geramos a tabela **tb_postagens** dentro do nosso Banco de dados **db_blogpessoal**. Agora vamos come√ßar a criar os M√©todos do CRUD do recurso Postagem, listados no Diagrama de Classes abaixo, nas Classes **PostagemService** e **PostagemController**.

```mermaid
classDiagram
class Postagem {
  - Id : Long
  - Titulo : String
  - Texto: String
  + GetAll()
  + GetById(long id)
  + GetByTitulo(string titulo)
  + Post(Postagem postagem)
  + Put(Postagem postagem)
  + Delete(long id)
}
class Auditable {
  - Data: DateTimeOffset
}
Postagem --|> Auditable: Herda
```

Ser√£o implementados 6 M√©todos: 

- 3 M√©todos de Busca (GET)
- 1 M√©todo de Persist√™ncia dos Objetos no Banco de dados (POST)
- 1 M√©todo de Atualiza√ß√£o dos Objetos persistidos no Banco de dados (PUT)
- 1 M√©todo para apagar Objetos persistidos no Banco de dados (DELETE)

A Classe **PostagemService** ser√° a Classe de Servi√ßo do Recurso Postagem, ou seja, onde implementaremos os M√©todos com as consultas ao Banco de dados e as Regras de Neg√≥cio da aplica√ß√£o. 

A Classe **PostagemController** ser√° a Classe Controladora do Recurso Postagem, ou seja, onde implementaremos os M√©todos respons√°veis por responder toda e qualquer Requisi√ß√£o (HTTP Request), que for enviada de fora da aplica√ß√£o para o recurso Postagem. 

> **Regras de Neg√≥cio:**  O termo regras de neg√≥cio refere-se √†s **diretrizes que definem ou restringem as a√ß√µes, mostrando como os M√©todos devem funcionar, o que deve ser checado em cada M√©todo e quais s√£o os limites da aplica√ß√£o**. Essas regras s√£o importantes para que a pessoa desenvolvedora tenha uma vis√£o clara do que deve ser feito, como e por qual raz√£o.

N√≥s iremos implementar os m√©todos do **CRUD** nas duas Classes, com os mesmos nomes, mas com responsabilidades diferentes. O M√©todo da Classe de Servi√ßo far√° o processamento dos dados enviados na Requisi√ß√£o, enquanto o M√©todo da Classe Controladora receber√° as Requisi√ß√µes e enviar√° os dados para a Classe de Servi√ßo. Ap√≥s a conclus√£o do processamento da Requisi√ß√£o, A Classe Controladora enviar√° uma Resposta HTTP, definida a partir do retorno do M√©todo da Classe de Servi√ßo, al√©m do resultado do processamento do M√©todo da Classe de Servi√ßo. 

<br />

<h2>üë£ Passo 01 - Implementar o M√©todo GetAll() na Classe PostagemService</h2>



Agora vamos come√ßar a implementar o c√≥digo da Classe **PostagemService**, como mostra a figura abaixo. Como iremos construir 6 M√©todos dentro da Classe de Servi√ßo, vamos construir por partes. Aqui construiremos apenas o primeiro M√©todo (**GetAll()**), que tem como objetivo listar todas as Postagens persistidas no Banco de dados.

<div align="left"><img src="https://i.imgur.com/DRnF9MC.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 01:** Importamos o Namespace **Data** (pasta Data do projeto Blog Pessoal).

**Linha 03:** Importamos o pacote **EntityFrameworkCore**.

**Linha 10:** Instanciamos um Objeto da Classe **AppDbContext**, chamado **_context** (somente leitura), √© a  implementa√ß√£o utilizada pelo EntityFramework para  aplicar  a  **Invers√£o  de  Controle (IoC)**, sempre que for necess√°rio. A Inje√ß√£o de Depend√™ncia define quais Classes ser√£o instanciadas automaticamente e em quais lugares ser√£o "Injetadas" quando houver necessidade. Observe que o Objeto **_context** ser√° somente leitura, porque durante o processamento da Requisi√ß√£o HTTP, a Classe de Servi√ßo deve se referir sempre ao mesmo Objeto da Classe **AppDbContext**, ao inv√©s de criar um novo.

> **Invers√£o de controle:** ou IOC √© um princ√≠pio de design de programas de computadores, onde a sequ√™ncia de chamadas dos  m√©todos √© invertida em rela√ß√£o √† programa√ß√£o tradicional, ou seja, ela  n√£o √© determinada diretamente pelo programador e sim pela Linguagem ou Framework. √â a transfer√™ncia da responsabilidade de Criar e Instanciar Objetos para a Linguagem ou Framework. A Inje√ß√£o de Depend√™ncias √© um tipo de Invers√£o de Controle. 

**Linhas 12 a 15:** Cria um **M√©todo Construtor**, que receber√° as **Inje√ß√µes de Depend√™ncia** necess√°rias para o desenvolvimento da Classe de Servi√ßo. Observe que o M√©todo Construtor receber√° como Par√¢metro o Contexto da aplica√ß√£o.

Em nosso exemplo, a Classe de Servi√ßo cria um ponto de inje√ß√£o do tipo **Postagem** e quando houver a necessidade o EntityFramework cria um novo **Objeto da Classe Postagem** atrav√©s da Interface **Service**. A grande vantagem de se utilizar a Inje√ß√£o de Depend√™ncias √© que voc√™ consegue instanciar e acessar os Objetos sem a necessidade de criar M√©todos Construtores na Classe Entidade (Model) ou criar/instanciar Objetos de forma manual, semelhante ao que era feito nas Sess√µes de Programa√ß√£o Orientada √† Objetos. Estamos transferindo esta responsabilidade para o EntityFramework e desta forma nos preocuparemos apenas com o processamento das Requisi√ß√µes HTTP.

**Linha 10:** Definimos o nome do Objeto da Interface **Service** (**postagemService**), que ser√° respons√°vel por implementar a **Inje√ß√£o de Depend√™ncias** e executar os M√©todos da Interface Service.

**Linhas 17 a 20:** Alteramos o M√©todo **GetAll()** para um **M√©todo Ass√≠ncrono**, atrav√©s da palavra reservada **async**, que promete retornar uma **Promise** (Promessa), contendo uma Collection List de Objetos da Classe Postagem. Como o M√©todo GetAll() lista v√°rios Objetos √© necess√°rio criar uma Collection para armazenar todos os Objetos.

> **Processamento Ass√≠ncrono**
>
> **Processamento Ass√≠ncrono** √© essencial para atividades que s√£o potencialmente pass√≠veis de bloqueio do sistema, como acesso ao Banco de dados na WEB. O acesso a um recurso da Web √†s vezes √© lento ou atrasado. Se tal atividade for bloqueada em um processo s√≠ncrono, todo o aplicativo dever√° esperar. Em um processo ass√≠ncrono, o aplicativo poder√° prosseguir com outra tarefa que n√£o dependa do recurso da Web at√© a tarefa potencialmente causadora do bloqueio terminar, com um resultado de sucesso ou de falha.
>
> Quando falamos de bloqueio da aplica√ß√£o, estamos falando em situa√ß√µes onde seu aplicativo p√°ra de responder, o que poderia levar a conclus√£o de que ele falhou quando, na verdade, est√° apenas aguardando. Quando voc√™ usa m√©todos ass√≠ncronos, o aplicativo continua a  responder e o usu√°rio poder√° aguardar a sua conclus√£o ou cancelar a opera√ß√£o.

**Linha 14:** Retorna a execu√ß√£o do M√©todo **ToListAsync()**, da Classe **DbContext**. Tra√ßando um paralelo com o MySQL, o M√©todo **ToListAsync()** sem par√¢metros seria o equivalente a instru√ß√£o: <code>SELECT * FROM tb_postagens;</code>, que lista todas as postagens da Tabela tb_postagens. Observe que na instru√ß√£o **return** foi inserido o comando **await** (aguarde), que na pr√°tica significa espere que a **Promise** seja resolvida (Todos os Objetos Postagem sejam inseridos na Collection List), antes de retornar a execu√ß√£o do M√©todo e o valor resolvido para a Classe que acionou o M√©todo.

> **Promise:** √â um objeto usado para processamento ass√≠ncrono. Uma Promise na pr√°tica √© uma promessa, que representa um valor que pode estar dispon√≠vel agora, no futuro ou nunca. Uma Promise √© como um "procurador" para um valor que n√£o √© necessariamente conhecido quando a promessa √© criada. Isso permite a associa√ß√£o de m√©todos de tratamento para eventos da a√ß√£o ass√≠ncrona num caso eventual de sucesso ou de falha. Isto permite que os m√©todos ass√≠ncronos retornem valores como m√©todos s√≠ncronos: ao inv√©s do valor final, o m√©todo ass√≠ncrono retorna uma *promessa* ao valor em algum momento no futuro.
>
> Uma Promise pode ter 3 estados: 
>
> - *pending* (pendente): Estado inicial, que n√£o foi realizada nem rejeitada.
> - *resolved* (resolvida): Sucesso na opera√ß√£o.
> - *rejected* (rejeitado):  Falha na opera√ß√£o.

**Informa√ß√µes importantes sobre M√©todos Ass√≠ncronos:**

- O c√≥digo ass√≠ncrono usa a Classe Task<T>, que √© utilizada para modelar o trabalho que est√° sendo feito em segundo plano (ass√≠ncrono).

- A palavra-chave **async** transforma um m√©todo s√≠ncrono (que segue o fluxo principal da aplica√ß√£o), em um m√©todo ass√≠ncrono (que cria um fluxo paralelo, em segundo plano), o que permite que voc√™ use a palavra-chave **await** em seu corpo.

- Quando a palavra-chave **await** √© aplicada, ela suspende o m√©todo de chamada e transfere o controle de volta ao seu chamador at√© que a tarefa em espera seja conclu√≠da.

- A palavra **await** s√≥ pode ser usada dentro de um m√©todo ass√≠ncrono.

- **Os M√©todos ass√≠ncronos (async) precisam ter uma palavra-chave await no corpo ou eles nunca transferir√£o o controle!**. Se a palavra await n√£o for utilizada no corpo de um m√©todo async, o compilador do C# gerar√° um aviso, mas o c√≥digo ser√° compilado e  executado como se fosse um m√©todo s√≠ncrono. Isso tamb√©m seria extremamente ineficiente, pois a m√°quina de estado gerada pelo compilador do C# para o m√©todo ass√≠ncrono n√£o realizaria nada.

<br />

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.threading.tasks.task-1?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Task</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/csharp/asynchronous-programming/async-scenarios" target="_blank"><b>Documenta√ß√£o: Programa√ß√£o Ass√≠ncrona</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model" target="_blank"><b>Documenta√ß√£o: Modelo de Tarefa Ass√≠ncrona</b></a></div>

<br />

<h2>üë£ Passo 02 - Criar a Classe PostagemController</h2>



Dentro do projeto **blogpessoal**, vamos criar a pasta **Controller**:

1. No lado direito superior, na Guia **Gerenciador de Solu√ß√µes**, clique com o bot√£o direito do mouse sobre o projeto  **blogpessoal** e clique na op√ß√£o **Adicionar ü°™ Nova Pasta**

2. Digite o nome da pasta (**Controller**), com a primeira letra mai√∫scula, seguindo o padr√£o do C# e pressione **enter** para concluir. O Gerenciador de Solu√ß√µes da aplica√ß√£o ficar√° semelhante a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/OazfLbR.png" title="source: imgur.com" /></div>

<br />

Vamos criar a **Classe PostagemController** na pasta **Controller**:

1. Clique com o bot√£o direito do mouse sobre a **pasta Controller** e na sequ√™ncia, clique na op√ß√£o **Adicionar ü°™ Classe**.
2. No item **Nome**, digite o nome da Classe (**PostagemController**), como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/ruEoYS7.png" title="source: imgur.com" /></div>

4. Clique no bot√£o **Adicionar** para concluir.
5. O **Gerenciador de Solu√ß√µes** da aplica√ß√£o ficar√° semelhante a imagem abaixo:

 <div align="center"><img src="https://i.imgur.com/GSby9x9.png" title="source: imgur.com" /></div>

Agora vamos come√ßar a criar o c√≥digo da Classe **PostagemController**, como mostra a figura abaixo. Como iremos construir 6 M√©todos dentro da Classe Controladora, vamos construir por partes. Aqui construiremos apenas o primeiro M√©todo, o **findAll()**, que tem como objetivo executar o M√©todo com o mesmo nome na **Classe PostagemService**.

<div align="left"><img src="https://i.imgur.com/WG0tKT3.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 1:** Importamos o pacote **Common** com os respectivos **decorators**, utilizados na implementa√ß√£o da Classe PostagemController.

**Linha 2:** Importamos a Classe **Postagem**, do Recurso **Postagem**.

**Linha 3:** Importamos a Classe **PostagemService**, do Recurso **Postagem**.

**Linha 5:** O decorator **@Controller** indica que a classe √© do tipo **RestController**, que receber√° requisi√ß√µes que ser√£o compostas por:

- **URL:** Endere√ßo da requisi√ß√£o (**endpoint**)
- **Verbo:** Define qual m√©todo HTTP ser√° acionado na Classe controladora.
- **Corpo da requisi√ß√£o (Request Body):** Objeto que cont√©m os dados que ser√£o persistidos no Banco de dados. Apenas as Requisi√ß√µes do tipo POST e PUT conseguem enviar dados no Corpo da Requisi√ß√£o.

Ap√≥s receber e processar a requisi√ß√£o, a Classe Controladora Responder√° com:

- Um **C√≥digo de Status HTTP** pertinente a opera√ß√£o que est√° sendo realizada.
- O resultado do processamento (Objetos de uma Classe, por exemplo) inserido diretamente no corpo da resposta (**Response Body**)

O par√¢metro inserido dentro dos par√™nteses √© usado para mapear as solicita√ß√µes para os m√©todos da classe controladora **PostagemController**, ou seja, definir a **URL** (endere√ßo) padr√£o do Recurso (**/postagens**). Ao digitar a URL do servidor seguida do caminho do Recurso (**http://localhost:4000/postagens**), a Classe Controladora enviar√° a Requisi√ß√£o para a Classe associada √† este endere√ßo (PostagemController) e o Respectivo M√©todo, de acordo com o caminho e o verbo HTTP (GET, POST, PUT ou DELETE).

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao configurar a URL do Recurso. Observe que configuramos a URL (/postagens) iniciando com uma barra, com letras min√∫sculas, usando o mesmo nome do m√≥dulo no plural, sem acentos, caracteres especiais e espa√ßos em branco. Lembre-se que todos os endere√ßos na WEB seguem este padr√£o.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

**Linha 7:** Cria um Construtor, que receber√° as Inje√ß√µes de Depend√™ncia. Como precisaremos ter acesso aos M√©todos da **Classe PostagemService**, foi injetado um Objeto desta Classe dentro do Construtor.

**Linha 9:** O decorator **@Get()** mapeia todas as Requisi√ß√µes **HTTP GET**, enviadas para um endere√ßo espec√≠fico, chamado **endpoint**, dentro do Recurso Postagem, para um M√©todo espec√≠fico que responder√° a Requisi√ß√£o, ou seja, ele indica que o M√©todo **findAll()**, responder√° a todas as requisi√ß√µes do tipo **HTTP GET**, enviadas no endere√ßo **http://localhost:4000/postagens/**.

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ATEN√á√ÉO:** *O Endere√ßo do endpoint ser√° igual ao Endere√ßo do Recurso apenas quando o decorator @Get() n√£o possuir um endere√ßo personalizado, como um par√¢metro por exemplo. Caso existam dois ou mais m√©todos do tipo GET ser√° necess√°rio personalizar o endere√ßo de cada M√©todo anotado com @Get("/endereco").* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

**Linha 10:** O decorator **@HttpCode(HttpStatus.OK)** indica que o M√©todo **findAll()**, ter√° como **Resposta HTTP** padr√£o o HTTP Status **OK ü°™ 200**, ou seja, quando a Resposta da Requisi√ß√£o for positiva, ser√° retornado o **HTTP Status OK ü°™ 200**. Caso a Resposta seja negativa (algo deu errado), a Resposta depender√° do erro.

**Linha 11:** Criamos o M√©todo **findAll()**, que promete retornar uma **Promise** (que ser√° enviada pela Classe PostagemService), contendo um array de Objetos Postagem. 

**Linha 12:** Executa o m√©todo **findAll()** (**M√©todo da Classe PostagemService**), que retornar√° **todos os Objetos da Classe Postagem** persistidos no Banco de dados dentro de um array. 

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods" target="_blank"><b>Documenta√ß√£o: HTTP Methods Request</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status" target="_blank"><b>Documenta√ß√£o: HTTP Status Code</b></a></div>

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/controllers" target="_blank"><b>Documenta√ß√£o: <i>Classe Controladora</i></b></a></div>

<div align="left"><img src="https://i.imgur.com/O6PILGE.png" title="source: imgur.com" width="25px"/> <a href="https://docs.nestjs.com/providers" target="_blank"><b>Documenta√ß√£o: <i>Provedores - Classe Controladora</i></b></a></div>

<br />

<h2>üë£ Passo 03 - Executar o projeto</h2>

1. Verifique se voc√™ est√° dentro da pasta do projeto, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/67GK3fX.png" title="source: imgur.com" /></div>

2. Digite o comando ***npm run start:dev***, para compilar e executar o nosso projeto **blogpessoal**. 

```bash
npm run start:dev
```

3. Se tudo deu certo, o resultado ser√° semelhante ao da figura abaixo:

<div align="center"><img src="https://i.imgur.com/hGAUI1Z.png" title="source: imgur.com" /></div>

4. Observe na imagem acima, na regi√£o destacada em amarelo, que o endpoint do tipo **GET** , apontando para o caminho (rota) **/postagens**, foi disponibilizado (mapeado).

<br />

<div align="left"><img src="https://i.imgur.com/bQGvf3h.png" title="source: imgur.com" width="30px"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_nest/tree/04_Listar_Postagens" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br />

<h2>üë£ Passo 04 - Inserir dados no Banco de dados</h2>

Como ainda n√£o criamos um M√©todo para Cadastrar Postagens (criaremos em breve), vamos inserir dois registros diretamente no Banco de Dados **db_blogpessoal**  na Tabela **tb_postagens** para testarmos o nosso M√©todo findAll().

1. Abra o <b>MySQL Workbench</b>.

2. Crie um novo arquivo SQL **(SQLFile)** e digite os comandos abaixo:

   ```sql
   USE db_blogpessoal;
   
   INSERT INTO tb_postagens (data, texto, titulo) 
   VALUES (current_timestamp(), 'Texto da postagem 01', 'Postagem 01');
   INSERT INTO tb_postagens (data, texto, titulo) 
   VALUES (current_timestamp(), 'Texto da postagem 02', 'Postagem 02');
   
   SELECT * FROM tb_postagens;
   ```

3. Selecione todas as linhas e clique no primeiro raio <img src="https://i.imgur.com/xH6Ei9O.png" title="source: imgur.com" /> para inserir os dados na tabela **tb_postagens**.

<div align="center"><img src="https://i.imgur.com/6yEc6tE.png" title="source: imgur.com" /></div>

4. A imagem acima mostra que os dados foram inseridos com sucesso!

<br />

<h2>üë£ Passo 05 - Testar no Insomnia</h2>

Para testar a aplica√ß√£o, utilizaremos o **Insomnia**. 

Para organizar os nossos testes, vamos criar uma **Collection** para guardar todas as nossas **Requisi√ß√µes do Projeto Blog Pessoal**. Na sequ√™ncia vamos criar dentro da Collection uma pasta chamada **Postagem** para guardar todas as requisi√ß√µes do Recurso Postagem. Para concluir, vamos criar uma requisi√ß√£o do tipo **GET**, dentro da pasta Postagem, para testar o nosso M√©todo **findAll()**.

<h3>7.1. Criando a Collection Blog Pessoal</h3>

1. Na janela principal do **Insomnia**, clique no bot√£o **Create** e clique na op√ß√£o **Request Collection**.

<div align="center"><img src="https://i.imgur.com/OzaorsG.png" title="source: imgur.com" /></div>

2. Na janela que ser√° aberta, informe o nome da Collection (**Blog Pessoal**) e clique no bot√£o **Create** para concluir. 

<div align="center"><img src="https://i.imgur.com/ZypryCY.png" title="source: imgur.com" /></div>

<h3>7.2. Criando a  Pasta Postagem</h3>

Vamos criar dentro da **Collection Blog Pessoal**, na **Pasta Postagem**, que guardar√° todas as requisi√ß√µes do **Recurso Postagem**.

1. Na **Collection Blog Pessoal**, clique no bot√£o <img src="https://i.imgur.com/Igkx9ev.png" title="source: imgur.com" width="25px"/>. No menu que ser√° aberto, clique na op√ß√£o **New Folder**.

<div align="center"><img src="https://i.imgur.com/ad9SBK1.png" title="source: imgur.com" /></div>

2. Na janela que ser√° aberta, informe o nome da pasta (**Postagem**) e clique no bot√£o **Create** para concluir. 

<div align="center"><img src="https://i.imgur.com/KIwSaAz.png" title="source: imgur.com" /></div>

<h3>7.3. Criando a  Requisi√ß√£o - Consultar todas as postagens - findAll()</h3>

Agora vamos criar a Requisi√ß√£o para o **M√©todo findAll()**:

1. Clique com o bot√£o direito do mouse sobre a **Pasta Postagem** para abrir o menu e clique na op√ß√£o **New Request**.

<div align="center"><img src="https://i.imgur.com/bFUVP3h.png" title="source: imgur.com" /></div>

2. Ser√° criada uma nova Requisi√ß√£o (New Request) dentro da pasta **Postagem**.

<div align="center"><img src="https://i.imgur.com/ZIi9kJp.png" title="source: imgur.com" /></div>

3. D√™ um duplo clique sobre a nova requisi√ß√£o (**New Request**), informe o nome da requisi√ß√£o (indicado na imagem abaixo na cor amarela) e pressione a tecla **enter** do seu teclado.

<div align="center"><img src="https://i.imgur.com/3eD6Zwy.png" title="source: imgur.com" /></div>

4. Selecione o M√©todo HTTP que ser√° utilizado (**GET**) na requisi√ß√£o, indicado na imagem abaixo na cor verde. 

<div align="center"><img src="https://i.imgur.com/mWPpKHD.png" title="source: imgur.com" /></div>

5. Configure a requisi√ß√£o conforme a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/NXrdnR4.png" title="source: imgur.com" /></div>

6. No item marcado em amarelo na imagem acima, informe o endere√ßo do endpoint da Requisi√ß√£o. A Requisi√ß√£o **Consultar Todas as postagens** foi configurada da seguinte maneira:

- A primeira parte do endere√ßo (http://localhost:4000) √© o endere√ßo do nosso servidor local. Quando a aplica√ß√£o estiver na nuvem, ele ser√° substitu√≠do pelo endere√ßo da nuvem (**Exemplo:** http://nomedaaplicacao.herokuapp.com).
- A segunda parte do endere√ßo √© o **endpoint** configurado no decorator ***@Controller()***, em nosso caso  **/postagens**. 

7. Para testar a requisi√ß√£o, com a aplica√ß√£o rodando, clique no bot√£o <img src="https://i.imgur.com/sy0V8Nx.png" title="source: imgur.com" width="60px"/>.

8. O resultado da requisi√ß√£o voc√™ confere na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/iUfzYul.png" title="source: imgur.com" width="75%"/></div>

9. Observe que a aplica√ß√£o al√©m de exibir os dados de todos os Objetos da Classe Postagem persistidos no Banco de dados, no Corpo da Resposta, ela tamb√©m retornar√° um **HTTP Status 200 ü°™ OK** (indicado em verde na imagem acima), informando que a Requisi√ß√£o foi bem sucedida!

<br />

<div align="left"><img src="https://i.imgur.com/g1HCNZy.png" title="source: imgur.com" width="30px" /><a href="https://docs.insomnia.rest/" target="_blank"><b>Documenta√ß√£o: Insomnia Rest</b></a></div>

<div align="left"><img src="https://i.imgur.com/muiNdkC.png" title="source: imgur.com" width="25px"/><a href="https://www.json.org/json-pt.html" target="_blank"><b>Site Oficial do JSON</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>