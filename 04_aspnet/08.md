<h1>Projeto 02 - Blog Pessoal - Classes PostagemController e PostagemService - M√©todo Consultar todas as Postagens</h1>



O que veremos por aqui:

1. Implementar o m√©todo GetAll() na Classe PostagemService
2. Criar a Classe PostagemController
3. Criar o m√©todo GetAll() para listar todas as Postagens na Classe PostagemController
4. Testar o M√©todo no Insomnia



<h2>1. O Recurso Postagem</h2>



Na etapa anterior, come√ßamos a construir o **Recurso Postagem**, a partir da **Classe Entidade (Model) Postagem**, onde implementamos todos os atributos do recurso Postagem e geramos a tabela **tb_postagens** dentro do nosso Banco de dados **db_blogpessoal**. Agora vamos come√ßar a criar os M√©todos do CRUD do recurso Postagem, listados no Diagrama de Classes abaixo, nas Classes **PostagemService** e **PostagemController**.

```mermaid
classDiagram
class Postagem {
  + Id : Long
  + Titulo : String
  + Texto: String
  + GetAll()
  + GetById(long id)
  + GetByTitulo(string titulo)
  + Create(Postagem postagem)
  + Update(Postagem postagem)
  + Delete(long id)
}
class Auditable {
  + Data: DateTimeOffset
}
Postagem --|> Auditable: Herda
```

Ser√£o implementados 6 M√©todos: 

- 3 M√©todos de Busca (GET)
- 1 M√©todo de Persist√™ncia dos Objetos no Banco de dados (POST)
- 1 M√©todo de Atualiza√ß√£o dos Objetos persistidos no Banco de dados (PUT)
- 1 M√©todo para apagar Objetos persistidos no Banco de dados (DELETE)

A Classe **PostagemService** ser√° a Classe de Servi√ßo do Recurso Postagem, ou seja, onde implementaremos os M√©todos com as consultas ao Banco de dados e as Regras de Neg√≥cio da aplica√ß√£o. 

A Classe **PostagemController** ser√° a Classe Controladora do Recurso Postagem, ou seja, onde implementaremos os M√©todos respons√°veis por responder toda e qualquer Requisi√ß√£o (HTTP Request), que for enviada de fora da aplica√ß√£o para o recurso Postagem. 

> **Regras de Neg√≥cio:**  O termo regras de neg√≥cio refere-se √†s **diretrizes que definem ou restringem as a√ß√µes, mostrando como os M√©todos devem funcionar, o que deve ser checado em cada M√©todo e quais s√£o os limites da aplica√ß√£o**. Essas regras s√£o importantes para que a pessoa desenvolvedora tenha uma vis√£o clara do que deve ser feito, como e por qual raz√£o.

N√≥s iremos implementar os m√©todos do **CRUD** nas duas Classes, com os mesmos nomes, mas com responsabilidades diferentes. O M√©todo da Classe de Servi√ßo far√° o processamento dos dados enviados na Requisi√ß√£o, enquanto o M√©todo da Classe Controladora receber√° as Requisi√ß√µes e enviar√° os dados para a Classe de Servi√ßo. Ap√≥s a conclus√£o do processamento da Requisi√ß√£o, A Classe Controladora enviar√° uma Resposta HTTP, definida a partir do retorno do M√©todo da Classe de Servi√ßo, al√©m do resultado do processamento do M√©todo da Classe de Servi√ßo. 

<br />

<h2>üë£ Passo 01 - Implementar o M√©todo GetAll() na Classe PostagemService</h2>



Agora vamos come√ßar a implementar o c√≥digo da Classe **PostagemService**, como mostra a figura abaixo. Como iremos construir 6 M√©todos dentro da Classe de Servi√ßo, vamos construir por partes. Aqui construiremos apenas o primeiro M√©todo (**GetAll()**), que tem como objetivo listar todas as Postagens persistidas no Banco de dados.

<div align="left"><img src="https://i.imgur.com/DRnF9MC.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 01:** Importamos o Namespace **Data** (pasta Data do projeto Blog Pessoal).

**Linha 03:** Importamos o pacote **EntityFrameworkCore**.

**Linha 10:** Instanciamos um Objeto da Classe **AppDbContext**, chamado **_context** (somente leitura). Esta √© a  forma utilizada utilizada pelo EntityFramework para  aplicar  a  **Invers√£o  de  Controle (IoC)**, sempre que for necess√°rio. A Inje√ß√£o de Depend√™ncia define quais Classes ser√£o instanciadas automaticamente e em quais lugares ser√£o "Injetadas" quando houver necessidade. Observe que o Objeto **_context** ser√° somente leitura, porque durante o processamento da Requisi√ß√£o HTTP, a Classe de Servi√ßo deve se referir sempre ao mesmo Objeto da Classe **AppDbContext**, ao inv√©s de criar um novo.

> **Invers√£o de controle:** ou IOC √© um princ√≠pio de design de programas de computadores, onde a sequ√™ncia de chamadas dos  m√©todos √© invertida em rela√ß√£o √† programa√ß√£o tradicional, ou seja, ela  n√£o √© determinada diretamente pelo programador e sim pela Linguagem ou Framework. √â a transfer√™ncia da responsabilidade de Criar e Instanciar Objetos para a Linguagem ou Framework. A Inje√ß√£o de Depend√™ncias √© um tipo de Invers√£o de Controle. 

**Linhas 12 a 15:** Cria um **M√©todo Construtor**, que receber√° as **Inje√ß√µes de Depend√™ncia** necess√°rias para o desenvolvimento da Classe de Servi√ßo. Observe que o M√©todo Construtor receber√° como Par√¢metro um Objeto da Classe **AppDbContext**, chamado **context**.

Em nosso exemplo, a Classe de Servi√ßo cria um ponto de inje√ß√£o do tipo **AppDbContext** e quando houver a necessidade o EntityFramework cria um novo **Objeto da Classe Postagem** atrav√©s da Interface **IPostagemService**. A grande vantagem de se utilizar a Inje√ß√£o de Depend√™ncias √© que voc√™ consegue instanciar e acessar os Objetos sem a necessidade de criar M√©todos Construtores na Classe Entidade (Model) ou criar/instanciar Objetos de forma manual, semelhante ao que era feito nas Sess√µes de Programa√ß√£o Orientada √† Objetos. Estamos transferindo esta responsabilidade para o EntityFramework e desta forma nos preocuparemos apenas com o processamento das Requisi√ß√µes HTTP.

**Linhas 17 a 20:** Alteramos o M√©todo **GetAll()** para um **M√©todo Ass√≠ncrono**, atrav√©s da palavra reservada **async**, que promete retornar uma **Promise** (Promessa), contendo uma Collection List de Objetos da Classe Postagem. Como o M√©todo GetAll() lista v√°rios Objetos √© necess√°rio criar uma Collection para armazenar todos os Objetos.

> **Processamento Ass√≠ncrono**
>
> **Processamento Ass√≠ncrono** √© essencial para atividades que s√£o potencialmente pass√≠veis de bloqueio do sistema, como acesso ao Banco de dados na WEB. O acesso a um recurso da Web √†s vezes √© lento ou atrasado. Se tal atividade for bloqueada em um processo s√≠ncrono, todo o aplicativo dever√° esperar. Em um processo ass√≠ncrono, o aplicativo poder√° prosseguir com outra tarefa que n√£o dependa do recurso da Web at√© a tarefa potencialmente causadora do bloqueio terminar, com um resultado de sucesso ou de falha.
>
> Quando falamos de bloqueio da aplica√ß√£o, estamos falando em situa√ß√µes onde seu aplicativo p√°ra de responder, o que poderia levar a conclus√£o de que ele falhou quando, na verdade, est√° apenas aguardando. Quando voc√™ usa m√©todos ass√≠ncronos, o aplicativo continua a  responder e o usu√°rio poder√° aguardar a sua conclus√£o ou cancelar a opera√ß√£o.

Note que a Classe **Task** recebe no par√¢metro Generic Type (`<T>`) uma Collection Gen√©rica do Tipo **IEnumerable**, que aramazenar√° Objetos do tipo Postagem. Lembre-se que a Interface **IEnumerable** √© a interface base para todas as Collections n√£o gen√©ricas que podem ser enumeradas, como a Collection List, por exemplo.

**Linha 19:** Retorna a execu√ß√£o do M√©todo **ToListAsync()**, da Classe **DbContext**. Tra√ßando um paralelo com o SQL, o M√©todo **ToListAsync()** sem par√¢metros seria o equivalente a instru√ß√£o: <code>SELECT * FROM tb_postagens;</code>, que lista todas as postagens da Tabela tb_postagens. 

Observe que na instru√ß√£o **return** foi inserido o comando **await** (aguarde), que na pr√°tica significa espere que a **Promise** seja resolvida (Todos os Objetos Postagem sejam inseridos na Collection List), antes de retornar a execu√ß√£o do M√©todo e o valor resolvido para a Classe que acionou o M√©todo.

> **Promise:** √â um objeto usado para processamento ass√≠ncrono. Uma Promise na pr√°tica √© uma promessa, que representa um valor que pode estar dispon√≠vel agora, no futuro ou nunca. Uma Promise √© como um "procurador" para um valor que n√£o √© necessariamente conhecido quando a promessa √© criada. Isso permite a associa√ß√£o de m√©todos de tratamento para eventos da a√ß√£o ass√≠ncrona num caso eventual de sucesso ou de falha. Isto permite que os m√©todos ass√≠ncronos retornem valores como m√©todos s√≠ncronos: ao inv√©s do valor final, o m√©todo ass√≠ncrono retorna uma *promessa* ao valor em algum momento no futuro.
>
> Uma Promise geralmente possui 3 estados: 
>
> - *pending* (pendente): Estado inicial, que n√£o foi realizada nem rejeitada.
> - *resolved* (resolvida): Sucesso na opera√ß√£o.
> - *rejected* (rejeitado):  Falha na opera√ß√£o.

**Informa√ß√µes importantes sobre M√©todos Ass√≠ncronos:**

- O c√≥digo ass√≠ncrono usa a Classe Task`<T>`, que √© utilizada para modelar o trabalho que est√° sendo feito em segundo plano (ass√≠ncrono).

- A palavra-chave **async** transforma um m√©todo s√≠ncrono (que segue o fluxo principal da aplica√ß√£o), em um m√©todo ass√≠ncrono (que cria um fluxo paralelo, em segundo plano), o que permite que voc√™ use a palavra-chave **await** em seu corpo.

- Quando a palavra-chave **await** √© aplicada, ela suspende o m√©todo de chamada e transfere o controle de volta ao seu chamador at√© que a tarefa em espera seja conclu√≠da.

- A palavra **await** s√≥ pode ser usada dentro de um m√©todo ass√≠ncrono.

- **Os M√©todos ass√≠ncronos (async) precisam ter uma palavra-chave await no corpo ou eles nunca transferir√£o o controle!**. Se a palavra await n√£o for utilizada no corpo de um m√©todo async, o compilador do C# gerar√° um aviso, mas o c√≥digo ser√° compilado e  executado como se fosse um m√©todo s√≠ncrono. Isso tamb√©m seria extremamente ineficiente, pois a m√°quina de estado gerada pelo compilador do C# para o m√©todo ass√≠ncrono n√£o realizaria nada.

<br />

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.threading.tasks.task-1?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Task</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/csharp/asynchronous-programming/async-scenarios" target="_blank"><b>Documenta√ß√£o: Programa√ß√£o Ass√≠ncrona</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model" target="_blank"><b>Documenta√ß√£o: Modelo de Tarefa Ass√≠ncrona</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/csharp/fundamentals/types/generics" target="_blank"><b>Documenta√ß√£o: Classes Gen√©ricas</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.ienumerable?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Interface IEnumerable</b></a></div>

<br />

<h2>üë£ Passo 02 - Criar a Classe PostagemController</h2>



Dentro do projeto **blogpessoal**, vamos criar a pasta **Controller**:

1. No lado direito superior, na Guia **Gerenciador de Solu√ß√µes**, clique com o bot√£o direito do mouse sobre o projeto  **blogpessoal** e clique na op√ß√£o **Adicionar ü°™ Nova Pasta**

2. Digite o nome da pasta (**Controller**), com a primeira letra mai√∫scula, seguindo o padr√£o do C# e pressione **enter** para concluir. O Gerenciador de Solu√ß√µes da aplica√ß√£o ficar√° semelhante a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/OazfLbR.png" title="source: imgur.com" /></div>

<br />

Vamos criar a **Classe PostagemController** na pasta **Controller**:

1. Clique com o bot√£o direito do mouse sobre a **pasta Controller** e na sequ√™ncia, clique na op√ß√£o **Adicionar ü°™ Classe**.
2. No item **Nome**, digite o nome da Classe (**PostagemController**), como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/ChcRW3C.png" title="source: imgur.com" /></div>

4. Clique no bot√£o **Adicionar** para concluir.
5. O **Gerenciador de Solu√ß√µes** da aplica√ß√£o ficar√° semelhante a imagem abaixo:

 <div align="center"><img src="https://i.imgur.com/WbPkTWY.png" title="source: imgur.com" /></div>

Agora vamos come√ßar a criar o c√≥digo da Classe **PostagemController**, como mostra a figura abaixo. Como iremos construir 6 M√©todos dentro da Classe Controladora, vamos construir por partes. Aqui construiremos apenas o primeiro M√©todo, o **GetAll()**, que tem como objetivo executar o M√©todo com o mesmo nome na **Classe PostagemService**.

<div align="left"><img src="https://i.imgur.com/0iRnSc9.png" title="source: imgur.com" /></div>

Vamos analisar o c√≥digo:

**Linha 01:** Importamos o Namespace **Model** (pasta Model do projeto Blog Pessoal), atrav√©s da palavra reservada **using**.

**Linha 02:** Importamos o Namespace **Service** (pasta Service do projeto Blog Pessoal), atrav√©s da palavra reservada **using**.

**Linha 03:** Importamos o Namespace do **Fluent Validation**, atrav√©s da palavra reservada **using**.

**Linha 04:** Importamos o Namespace do **AspNetCore.Mvc**, atrav√©s da palavra reservada **using**. Este Pacote possui os M√©todos necess√°rios para criar a Classe Controladora.

**Linha 08:** A Anota√ß√£o **[Route("~/postagens")]** √© utilizada para mapear todas as Requisi√ß√µes HTTP, recebidas na **URL** (endere√ßo) padr√£o do Recurso Postagem (**/postagens**), para a classe controladora **PostagemController**. Quando a API receber uma Requisi√ß√£o HTTP com o endere√ßo **http://localhost:5000/postagens**, a Classe Controladora PostagemController ir√° receber e processar a Requisi√ß√£o com o respectivo M√©todo, de acordo com o caminho e o verbo HTTP (GET, POST, PUT ou DELETE). 

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao configurar a URL do Recurso. Observe que configuramos a URL (/postagens) iniciando com uma barra, com letras min√∫sculas, sem acentos, caracteres especiais e espa√ßos em branco. Lembre-se que todos os endere√ßos na WEB seguem este padr√£o.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

**Linha 09:** A Anota√ß√£o **[ApiController]** indica que a classe √© do tipo **RestController**, que receber√° requisi√ß√µes que ser√£o compostas por:

- **URL:** Endere√ßo da requisi√ß√£o (**endpoint**)
- **Verbo:** Define qual m√©todo HTTP ser√° acionado na Classe controladora.
- **Corpo da requisi√ß√£o (Request Body):** Objeto que cont√©m os dados que ser√£o persistidos no Banco de dados. Apenas as Requisi√ß√µes do tipo POST e PUT conseguem enviar dados no Corpo da Requisi√ß√£o.

Ap√≥s receber e processar a requisi√ß√£o, a Classe Controladora Responder√° com:

- Um **C√≥digo de Status HTTP** pertinente a opera√ß√£o que est√° sendo realizada.
- O resultado do processamento (Objetos de uma Classe, por exemplo) inserido diretamente no corpo da resposta (**Response Body**)

**Linha 10:** A Classe PostagemController foi assinada como Heran√ßa da Classe **ControllerBase**, que √© respons√°vel por definir a estrutura b√°sica de um controlador MVC.

**Linha 12:** Instanciamos um Objeto da Interface **IPostagemService**, chamado **_postagemService** (somente leitura). Este objeto ser√° utilizado pelo EntityFramework para  aplicar  a  **Invers√£o  de  Controle (IoC)**, sempre que for necess√°rio. Observe que o Objeto **_postagemService** ser√° somente leitura, porque durante o processamento da Requisi√ß√£o HTTP, a Classe Controladora deve se referir sempre ao mesmo Objeto da Interface **IPostagemService**, ao inv√©s de criar um novo.

> **Por qu√™ estamos instanciando a Interface IPostagemService ao √≠nv√©s da Classe PostagemService?**
>
> Lembre-se que quando fizemos o registro do Servi√ßo PostagemService na Classe Program, n√≥s passamos como par√¢metros a Interface e a Classe que definem o servi√ßo. Na Classe Controladora os servi√ßos s√£o adicionados como um par√¢metro do M√©todo Construtor e o runtime do ASP.NET resolve o servi√ßo de cont√™iner. Os servi√ßos s√£o normalmente definidos usando interfaces, que s√£o inseridas atrav√©s de um Inje√ß√£o de Depend√™ncia, gra√ßas ao suporte interno do ASP.NET. 
>
> Neste caso utilizamos uma Interface para quebrar as depend√™ncias entre as classes de n√≠vel superior (PostagemService) e inferior (PostagemController). Em outras palavras, ambas as classes dependem da interface e n√£o mais uma da outra.
>
> Esse princ√≠pio melhora a capacidade de reutiliza√ß√£o do seu c√≥digo e limita o efeito cascata se voc√™ precisar alterar as classes de n√≠vel inferior. Mas mesmo se voc√™ implement√°-lo perfeitamente, ainda mant√©m uma depend√™ncia na classe de n√≠vel inferior. A interface apenas desacopla o uso da classe de n√≠vel inferior, mas n√£o sua instancia√ß√£o. Em algum lugar do seu c√≥digo, voc√™ precisa instanciar a implementa√ß√£o da interface. Isso evita que voc√™ substitua a implementa√ß√£o da interface por uma diferente.
>
> <div align="center"><img src="https://i.imgur.com/9b8RlA1.png" title="source: imgur.com" width="90%" /></div>
>
> O objetivo da t√©cnica de inje√ß√£o de depend√™ncia √© remover essa depend√™ncia separando o uso da cria√ß√£o do objeto. Isso reduz a quantidade de c√≥digo repetitivo necess√°rio e melhora a flexibilidade.

**Linha 13:** Seguindo o mesmo pr√≠ncipio da linha 12, instanciamos um Objeto da Interface **IValidator**, chamado **_postagemValidator**, que ser√° utilizado para validar os Objetos da Classe Postagem, nos M√©todos **Post** e **Put**.

**Linhas 15 a 22:** Cria um **M√©todo Construtor**, que receber√° as **Inje√ß√µes de Depend√™ncia** necess√°rias para o desenvolvimento da Classe de Servi√ßo. Observe que o M√©todo Construtor receber√° como Par√¢metros as Inje√ß√µes de Depend√™ncia **_postagemService** e **_postagemValidator**.

**Linhas 24 a 28:** Criamos o M√©todo **GetAll()** como um **M√©todo Ass√≠ncrono**, atrav√©s da palavra reservada **async**, que promete retornar um Objeto **ActionResult**, contendo uma Collection List de Objetos da Classe Postagem, recebidas do **M√©todo GetAll() da Classe de Servi√ßo PostagemService**. 

> A Classe **ActionResult** √© uma implementa√ß√£o da Interface **IActionResult**, que representa o resultado de um m√©todo de a√ß√£o de forma ass√≠ncrona. 

**Linha 24:** A Anota√ß√£o **[HttpGet]** mapeia todas as Requisi√ß√µes **HTTP GET**, enviadas para um endere√ßo espec√≠fico, chamado **endpoint**, dentro do Recurso Postagem, para um M√©todo espec√≠fico que responder√° a Requisi√ß√£o, ou seja, ele indica que o M√©todo **GetAll()**, responder√° a todas as requisi√ß√µes do tipo **HTTP GET**, enviadas no endere√ßo **http://localhost:5000/postagens/**.

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ATEN√á√ÉO:** *O Endere√ßo do endpoint ser√° igual ao Endere√ßo do Recurso apenas quando a anota√ß√£o [HttpGet] n√£o possuir um endere√ßo personalizado, como um par√¢metro. Caso existam dois ou mais m√©todos do tipo GET ser√° necess√°rio personalizar o endere√ßo de cada M√©todo anotado com algo do tipo [HttpGet("endere√ßo")].* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

**Linha 27:** Atrav√©s da palavra reservada **return**, retornaremos o resultado da execu√ß√£o do M√©todo **Ok()**. O M√©todo **Ok()** cria uma  **Resposta HTTP** padr√£o, com o HTTP Status **OK ü°™ 200** e insere no Corpo da Resposta um JSON, contendo a Cole√ß√£o de Objetos Postagem encontrados no Banco de dados.   

Por se tratar de uma Cole√ß√£o, a Resposta da Requisi√ß√£o sempre ser√° positiva, o m√°ximo que pode acontecer √© o M√©todo GetAll() retornar uma Cole√ß√£o vazia, caso n√£o exista nenhum registro no Banco de dados.

<br />

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods" target="_blank"><b>Documenta√ß√£o: HTTP Methods Request</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status" target="_blank"><b>Documenta√ß√£o: HTTP Status Code</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Classe ControllerBase</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/aspnet/core/web-api/?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Criar APIs Web com o ASP.NET Core</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/aspnet/core/mvc/controllers/dependency-injection?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Inje√ß√£o de depend√™ncia em controladores</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.mvc.actionresult?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Classe ActionResult</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.ok?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: M√©todo Ok()</b></a></div>

<br />

<h2>üë£ Passo 03 - Executar o projeto</h2>



Para executarmos o Projeto, clique no bot√£o <img src="https://i.imgur.com/gPnfOVk.png" title="source: imgur.com" width="8%"/>**Run http**, na **Barra de Ferramentas Principal** (indicado em verde na imagem):

![Imagem 30](https://i.imgur.com/Ya4O50P.png)

<br />

<h2>üë£ Passo 04 - Inserir dados no Banco de dados</h2>



Como ainda n√£o criamos um M√©todo para Cadastrar Postagens (criaremos em breve), vamos inserir dois registros diretamente no Banco de Dados **db_blogpessoal** na Tabela **tb_postagens** para testarmos o nosso M√©todo GetAll().

1. Abra o **SQL Server Management Studio** e conecte-se com o **SQL Server**.

2. Na Barra de Ferramentas do **SQL Server Management Studio**, clique no bot√£o **Nova Consulta**, para criar uma nova janela de consulta:

<div align="center"><img src="https://i.imgur.com/gjdIRZ1.png" title="source: imgur.com" /></div>

3. Crie um novo arquivo SQL **(SQLFile)** e digite os comandos abaixo:

```sql
USE db_blogpessoal;
GO

INSERT INTO tb_postagens (Titulo, Texto, Data)
VALUES ('Postagem 01', 'Texto da Postagem 01', SYSDATETIMEOFFSET());
INSERT INTO tb_postagens (Titulo, Texto, Data)
VALUES ('Postagem 02', 'Texto da Postagem 02', SYSDATETIMEOFFSET());
GO

SELECT * FROM tb_postagens;
GO
```

4. Para executar a Query, selecione todas as linhas e clique no comando Executar <img src="https://i.imgur.com/hY0lt5I.png" title="source: imgur.com" />, dispon√≠vel na Barra de Ferramentas do **SQL Server Management Studio**:

<div align="center"><img src="https://i.imgur.com/3EXuyTV.png" title="source: imgur.com" /></div>

5. O resultado ser√° semelhante a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/zfFJzAS.png" title="source: imgur.com" /></div>

A imagem acima mostra que os dados foram inseridos com sucesso!

<br />

<h2>üë£ Passo 05 - Testar no Insomnia</h2>



Para testar a aplica√ß√£o, utilizaremos o **Insomnia**. 

Para organizar os nossos testes, vamos criar uma **Collection** para guardar todas as nossas **Requisi√ß√µes do Projeto Blog Pessoal**. Na sequ√™ncia vamos criar dentro da Collection uma pasta chamada **Postagem** para guardar todas as requisi√ß√µes do Recurso Postagem. Para concluir, vamos criar uma requisi√ß√£o do tipo **GET**, dentro da pasta Postagem, para testar o nosso M√©todo **GetAll()**.

<br />

<h3>5.1. Criando a Collection Blog Pessoal</h3>



1. Na janela principal do **Insomnia**, clique no bot√£o **Create** e clique na op√ß√£o **Request Collection**.

<div align="center"><img src="https://i.imgur.com/NhdF4d0.png" title="source: imgur.com" /></div>

2. Na janela que ser√° aberta, informe o nome da Collection (**Blog Pessoal**) e clique no bot√£o **Create** para concluir. 

<div align="center"><img src="https://i.imgur.com/eYp2qUL.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>5.2. Criando a  Pasta Postagem</h3>



Vamos criar dentro da **Collection Blog Pessoal**, na **Pasta Postagem**, que guardar√° todas as requisi√ß√µes do **Recurso Postagem**.

1. Na **Collection Blog Pessoal**, clique no bot√£o <img src="https://i.imgur.com/3Ou2SAZ.png" title="source: imgur.com" width="6%"/>. No menu que ser√° aberto, clique na op√ß√£o **New Folder**.

<div align="center"><img src="https://i.imgur.com/gIGZFHc.png" title="source: imgur.com" /></div>

2. Na janela que ser√° aberta, informe o nome da pasta (**Postagem**) e clique no bot√£o **Create** para concluir. 

<div align="center"><img src="https://i.imgur.com/2rUhRGT.png" title="source: imgur.com" width="80%"/></div>

<br />

<h3>5.3. Criando a  Requisi√ß√£o - Consultar todas as postagens - GetAll()</h3>



Agora vamos criar a Requisi√ß√£o para o **M√©todo GetAll()**:

1. Clique com o bot√£o direito do mouse sobre a **Pasta Postagem** para abrir o menu e clique na op√ß√£o **New HTTP Request**.

<div align="center"><img src="https://i.imgur.com/KvRI8b2.png" title="source: imgur.com" /></div>

2. Ser√° criada uma nova Requisi√ß√£o (New Request) dentro da pasta **Postagem**.

<div align="center"><img src="https://i.imgur.com/ZIi9kJp.png" title="source: imgur.com" /></div>

3. D√™ um duplo clique sobre a nova requisi√ß√£o (**New Request**), informe o nome da requisi√ß√£o (indicado na imagem abaixo na cor amarela) e pressione a tecla **enter** do seu teclado.

<div align="center"><img src="https://i.imgur.com/3eD6Zwy.png" title="source: imgur.com" /></div>

4. Selecione o M√©todo HTTP que ser√° utilizado (**GET**) na requisi√ß√£o, indicado na imagem abaixo na cor verde. 

<div align="center"><img src="https://i.imgur.com/mWPpKHD.png" title="source: imgur.com" /></div>

5. Configure a requisi√ß√£o conforme a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/uP6fxlX.png" title="source: imgur.com" /></div>

6. No item marcado em amarelo na imagem acima, informe o endere√ßo do endpoint da Requisi√ß√£o. A Requisi√ß√£o **Consultar Todas as postagens** foi configurada da seguinte maneira:

- A primeira parte do endere√ßo (http://localhost:5000) √© o endere√ßo do nosso servidor local. Quando a aplica√ß√£o estiver na nuvem, ele ser√° substitu√≠do pelo endere√ßo da nuvem (**Exemplo:** http://nomedaaplicacao.onrender.com).
- A segunda parte do endere√ßo √© o **endpoint** configurado anota√ß√£o **[Route("~/postagens")]**, em nosso caso  **/postagens**. 

7. Para testar a requisi√ß√£o, com a aplica√ß√£o rodando, clique no bot√£o <img src="https://i.imgur.com/sy0V8Nx.png" title="source: imgur.com" width="60px"/>.

8. O resultado da requisi√ß√£o voc√™ confere na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/0dn8tZn.png" title="source: imgur.com" width="75%"/></div>

9. Observe que a aplica√ß√£o al√©m de exibir os dados de todos os Objetos da Classe Postagem persistidos no Banco de dados, no Corpo da Resposta, ela tamb√©m retornar√° um **HTTP Status 200 ü°™ OK** (indicado em verde na imagem acima), informando que a Requisi√ß√£o foi bem sucedida!
9. Caso o Projeto ASP.NET n√£o esteja em Execu√ß√£o, o Insomnia retornar√° a mensagem abaixo:

<div align="center"><img src="https://i.imgur.com/Y2iNu9v.png" title="source: imgur.com" /></div>

11. Execute o seu Projeto e teste novamente!

<br />

<div align="left"><img src="https://i.imgur.com/g1HCNZy.png" title="source: imgur.com" width="5%" /><a href="https://docs.insomnia.rest/" target="_blank"><b>Documenta√ß√£o: Insomnia Rest</b></a></div>

<div align="left"><img src="https://i.imgur.com/14IR5P4.png" title="source: imgur.com" width="5%"/><a href="https://www.json.org/json-pt.html" target="_blank"><b>Site Oficial do JSON</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>