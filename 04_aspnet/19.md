<h1>Projeto 02 - Blog Pessoal - Ecossistema da Seguran√ßa</h1>



O que veremos por aqui:

1. Criar a Classe Settings
2. Criar a Interface IAuthService
3. Criar a Classe AuthService
4. Registrar a Classe AuthService na Classe Program
5. Atualizar a Classe UserController
6. Atualizar a Classe TemaController
7. Atualizar a Classe PostagemController
8. Testar o M√©todo de Login e Atualizar todas as Requisi√ß√µes no Insomnia

<br />

<h2>1. O Ecossistema da Seguran√ßa</h2>



Nesta etapa vamos come√ßar a construir o Ecossistema da Seguran√ßa, que  ser√° utilizado para habilitar e implementar a seguran√ßa do Blog Pessoal. Atrav√©s do Ecossistema da Seguran√ßa ser√° poss√≠vel realizar a autentica√ß√£o dos  usu√°rios a  partir de uma tabela no Banco de dados. Para isso √©  necess√°rio enviar os atributos usuario (e-mail) e a senha para que o  Ecossistema da Seguran√ßa valide as credenciais do usu√°rio, gere e valide o Token JWT, que permitir√° acessar os endpoints protegidos da  aplica√ß√£o.

O Ecossistema da Seguran√ßa utilizar√° a Classe Entidade Auxiliar **UserLogin**, criada anteriormente. Chamamos esta Classe de Auxiliar porqu√™ ela n√£o ir√° gerar uma tabela no Banco de dados, servir√° apenas para enviar os dados do usu√°rio para o  Ecossistema da Seguran√ßa. Relembre atrav√©s do Diagrama abaixo a estrutura da Classe **UserLogin**:

```mermaid
classDiagram
class UserLogin{
  + id : Long
  + nome : String
  + usuario : String
  + senha : String
  + foto : String
  + token : String
}
```

<br />

<h2>üë£ Passo 01 - Criar a Classe Settings</h2>



Dentro do projeto **blogpessoal**, vamos criar a pasta **Security**, que ser√° utilizada para implementar o Ecossistema da Seguran√ßa:

1. No lado direito superior, na Guia **Gerenciador de Solu√ß√µes**, clique com o bot√£o direito do mouse sobre o projeto  **blogpessoal** e clique na op√ß√£o **Adicionar ü°™ Nova Pasta**

2. Digite o nome da pasta (**Security**), com a primeira letra mai√∫scula, seguindo o padr√£o do C# e pressione **enter** para concluir. 

<br />

Na sequ√™ncia, vamos criar a **Classe Settings** na pasta **Security**.

1. Clique com o bot√£o direito do mouse sobre a **pasta Security** e na sequ√™ncia, clique na op√ß√£o **Adicionar ü°™ Classe**
2. No item **Nome**, digite o nome da Classe (**Settings**)
3. Clique no bot√£o **Adicionar** para concluir.

<br />

Agora vamos criar e analisar o c√≥digo da **Classe Settings**:

<div align="center"><img src="https://i.imgur.com/9gZbdbS.png" title="source: imgur.com" /></div>

**Linha 05:** Foi criado o atributo **secret**. Este atributo armazenar√° a Chave de assinatura do Token JWT (secret). Este Atributo foi definido com um valor, porque este valor ser√° constante, ou seja, nunca ser√° modificado. Foi definido tamb√©m o modificador **static**, porque o atributo deve estar associado **apenas e exclusivamente** a esta Classe, ou seja, √© uma vari√°vel de Classe e n√£o do Objeto. Tamb√©m foi definido o modificador **private**, para manter o encapsulamento.

O valor atribu√≠do ao atributo **secret** √© uma chave encriptada aleat√≥ria, gerada atrav√©s do algoritmo de Criptografia  **AES**.

> O **Advanced Encryption Standard (AES)** √©  uma especifica√ß√£o para a criptografia de dados eletr√¥nicos estabelecida  pelo Instituto Nacional de Padr√µes e Tecnologia (NIST) dos EUA em 2001.  AES √© amplamente utilizado hoje em dia, pois √© um algoritmo que geram  chaves muito fortes, dif√≠ceis de serem quebradas.

Para gerar esta chave, utilizamos o site All Keys Generator (<a href="https://www.keygen.io/" target="_blank"><b>https://www.keygen.io/</b></a>), na op√ß√£o **SHA 256-bit Key**, que permite gerar chaves encriptadas aleat√≥rias no formato **SHA 256**:

<div align="center"><img src="https://i.imgur.com/AfTCWuK.png" title="source: imgur.com" /></div>

**Linha 07:** Foram criados os M√©todos Get e Set utilizando uma implementa√ß√£o simplificada.

<br />

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/SHA-2" target="_blank"><b>Algoritmo SHA256.</b></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://www.keygen.io" target="_blank"><b>Ferramenta: Keygen IO</b></div>

<br />

<h2>üë£ Passo 02 - Criar a Interface IAuthService</h2>



Vamos criar a **Interface IAuthService** na pasta **Security**.

1. Clique com o bot√£o direito do mouse sobre a **pasta Security** e na sequ√™ncia, clique na op√ß√£o **Adicionar ü°™ Novo item**
2. Na janela **Adicionar Novo Item**, Selecione a op√ß√£o **Interface**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/9dkGfqs.png" title="source: imgur.com" /></div>

3. No item **Nome**, digite o nome da Interface (**IAuthService**)

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao criar a Interface Service. Na Linguagem C# toda a Interface inicia o nome com a Letra I (mai√∫scula), porque geralmente a Classe que implementa a Interface tem o mesmo nome da Interface.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

Agora vamos criar o c√≥digo da **Interface IAuthService**:

```c#
using blogpessoal.Model;

namespace blogpessoal.Security
{
    public interface IAuthService
    {
        Task<UserLogin?> Autenticar(UserLogin userLogin);
    }
}
```

Observe que foi assinado apenas um M√©todo na Interface **IAuthService**, chamado **Autenticar**, que ser√° respons√°vel por efetuar o login do Usu√°rio e Gerar o Token JWT.

<br />

<h2>üë£ Passo 03 - Criar a Classe AuthService</h2>



Dentro da pasta **Security**, vamos criar a pasta **Implements**:

1. No lado direito superior, na Guia **Gerenciador de Solu√ß√µes**, clique com o bot√£o direito do mouse sobre a pasta **Security** e clique na op√ß√£o **Adicionar ü°™ Nova Pasta**
2. Digite o nome da pasta (**Implements**), com a primeira letra mai√∫scula, seguindo o padr√£o do C# e pressione **enter** para concluir.

<br />

Vamos criar a **Classe AuthService** na pasta **Implements**, dentro da pasta **Service**:

1. Clique com o bot√£o direito do mouse sobre a **pasta Implements**, localizada dentro da pasta **Security**, e na sequ√™ncia, clique na op√ß√£o **Adicionar ü°™ Classe**.
2. No item **Nome**, digite o nome da Classe (**AuthService**)

Vamos implementar e analisar a Classe **AuthService**:

<div align="center"><img src="https://i.imgur.com/DfLeKWE.png" title="source: imgur.com" /></div>

**Linha 01:** Importamos o Namespace **Model** (pasta Model do projeto Blog Pessoal).

**Linha 02:** Importamos o Namespace **Service** (pasta Service do projeto Blog Pessoal).

**Linha 03:** Importamos o pacote **IdentityModel.Tokens**, respons√°vel por Criar os elementos Token JWT (Claims, Signature, entre outros).

**Linha 04:** Importamos o pacote **IdentityModel.Tokens.Jwt**, respons√°vel por Criar o Token JWT.

**Linha 05:** Importamos o pacote **Security.Claims**, respons√°vel por representar os Claims do Token JWT.

**Linha 06:** Importamos o pacote **System.Text** (Opcional), respons√°vel por exibir mensagens na tela do console.

**Linha 10:** Observe que na assinatura da Classe **AuthService**, vamos adicionar **:** (dois pontos) e na sequ√™ncia o nome da Interface que ser√° implementada (**IAuthService**). 

 **Linha 12:** Instanciamos um Objeto da Interface **IUserService**, chamado **_userService** (somente leitura). Atrav√©s desta Inje√ß√£o de Depend√™ncias, teremos acesso aos M√©todos da Classe **UserService**, que nos permitir√° efetuar consultas no Banco de dados da aplica√ß√£o.

**Linhas 14 a 17:** Cria um **M√©todo Construtor**, que receber√° a **Inje√ß√µes de Depend√™ncia** necess√°rias para o desenvolvimento da Classe de Servi√ßo. Observe que o M√©todo Construtor receber√° como Par√¢metro um Objeto da Interface **UserService**, chamado **userService**.

Em nosso exemplo, a Classe de Servi√ßo cria um ponto de inje√ß√£o do tipo **IUserService** e quando houver a necessidade o EntityFramework cria um novo **Objeto da Classe Usuario** atrav√©s da Interface **IUserService**. Atrav√©s deste Objeto, checaremos se o o usu√°rio e senha enviados no login (Objeto da Classe UserLogin), existem ou n√£o no Banco de dados.

**Linhas 19 a 55:** Implementamos o M√©todo **Autenticar(UserLogin usuarioLogin)** para um **M√©todo Ass√≠ncrono**, atrav√©s da palavra reservada **async**, que promete retornar uma **Promise** (Promessa), contendo um Objeto da Classe **UserLogin**, contendo os dados do usu√°rio que n√£o foram enviados no login (id, nome e foto) e o Token JWT, que permitir√° o usu√°rio acessar os endpoints protegidos da aplica√ß√£o.

Observe que o M√©todo **Autenticar(UserLogin usuarioLogin)** receber√° um Objeto da Classe **UserLogin**, que possuir√° apenas 2 atributos preenchidos: **usuario (e-mail) e a senha**.

**Linha 21:** Cria a vari√°vel **FotoDefault** contendo o link para a foto padr√£o para usu√°rios que n√£o cadastraram uma foto.

**Linhas 23 e 24:** Verifica se o Objeto **usuarioLogin** √© nulo e se os atributos **usuario e senha** s√£o nulos ou vazio. Caso uma destas condi√ß√µes seja verdadeira, o M√©todo **Autenticar(UserLogin usuarioLogin)** retornar√° nulo (null).

**Linha 26:** Cria o Objeto **BuscaUsuario**, da Classe **User**, que receber√° o resultado da execu√ß√£o do M√©todo **GetByUsuario(usuarioLogin.Usuario)**, da Interface **UserService**, que retorna apenas um Objeto espec√≠fico (o primeiro), cujo atributo **usuario** seja  igual ao valor do atributo **usuario** do Objeto **userLogin**. 

**Linhas 28 e 29:** Verifica se o Objeto **BuscaUsuario** √© nulo, ou seja, se o usu√°rio que est√° tentando autenticar n√£o foi encontrado. Caso esta condi√ß√£o seja verdadeira, o M√©todo **Autenticar(UserLogin usuarioLogin)** retornar√° nulo (null).

**Linhas 71 e 72:** Atrav√©s do **M√©todo Verify(string senhaDigitada, string senhaPersistida)**, do Pacote **Bcrypt**, vamos checar se a senha do Objeto **usuarioLogin** √© diferente da senha do Objeto **BuscaUsuario**. Caso esta condi√ß√£o seja verdadeira, ou seja, as senhas n√£o s√£o iguais, o M√©todo **Verify(string senhaDigitada, string senhaPersistida)** retornar√° nulo (null).

Em linhas gerais, o M√©todo **Verify(string senhaDigitada, string senhaPersistida)**, utiliza o algoritmo **BCrypt** na senha  digitada pelo usu√°rio e depois checa se esta senha criptografada √© equivalente a senha criptografada persistida no Banco de dados. Como este M√©todo √© do tipo **bool**, ele retornar√° **true** se as senhas forem iguais.

**Linha 34:** Cria um Objeto da Classe **JwtSecurityTokenHandler**, chamado **tokenHandler**, que representa o **Token JWT**.

**Linha 35:** Cria uma vari√°vel do tipo **byte**, chamado **tokenKey**, que receber√° o atributo **secret**, da Classe **Settings**, codificado no formato **UTF-8**.

> **UTF-8** √© a p√°gina de c√≥digo universal para internacionaliza√ß√£o de caracteres, que √© capaz  de codificar todo o conjunto de caracteres Unicode. Ele √© usado amplamente na Web e √© o padr√£o para plataformas baseadas em Unix, como o Linux, por exemplo.

**Linhas 36 a 44:** Cria um Objeto da Classe **SecurityTokenDescriptor**, chamado **tokenDescriptor**, que ser√° respons√°vel por armazenar todos os atributos relacionados ao **Token JWT**, ou seja, o **Payload** e a **Assinatura**. 

> **payload:** √© um Objeto JSON, que cont√©m as declara√ß√µes do Token JWT, definidas no padr√£o JSON WEB Token. As declara√ß√µes s√£o as informa√ß√µes sobre uma entidade (normalmente, o usu√°rio) e alguns dados adicionais.

Observe que dentro deste Objeto ser√£o inseridas as **Claims Subject (usuario) e Expires(data e hora de validade do token)**, al√©m da **assinatura do Token (SigningCredentials)**.

> **Claims** s√£o declara√ß√µes inseridas no payload do Token JWT, ou seja, s√£o informa√ß√µes declaradas sobre um assunto.
>
> **Exemplo:**
>
> ```json
> {
> 	"unique_name": "admin@email.com.br"
> }
> ```
>
> **unique_name** √© uma **claim**, que cont√©m o e-mail do usu√°rio.

**Linhas 38 a 41:** Cria um Objeto da Classe **ClaimsIdentity**, que √© uma implementa√ß√£o concreta de uma identidade baseada em declara√ß√µes, ou seja, uma identidade descrita por uma cole√ß√£o de declara√ß√µes. Uma declara√ß√£o √© uma representa√ß√£o sobre uma entidade feita por um emissor que descreve uma propriedade, um direito ou alguma outra qualidade dessa entidade. Em nosso exemplo, ser√° descrito o **usu√°rio que √© o dono do Token JWT**.

**Linha 40:** O atributo **Subject** √© respons√°vel por inserir a **claim subject**. Note que criamos um Objeto da Classe **Claim** no atributo **Subject**, que representa uma declara√ß√£o (Claim). Para criar a declara√ß√£o utilizamos o M√©todo Construtor da Classe Claim, que possui **2 par√¢metros: Tipo e Valor.**

**Tipo:** O Tipo √© representado por um Objeto da Classe **ClaimTypes**, que possui uma lista de poss√≠veis declara√ß√µes. Em nosso projeto, utilizaremos apenas a declara√ß√£o **Name**, que receber√° o usu√°rio que √© dono do Token JWT.

**Valor:** √â o valor que ser√° armazenado na declara√ß√£o. Em nosso exemplo, passamos o atributo **usuario** (e-mail), do Objeto **userLogin**.

Por se tratar de um Array, podemos adicionar outras declara√ß√µes (Claims), al√©m da Claim Name. 

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao criar a Camada Security. N√£o adicione dados sens√≠veis do usu√°rio como a senha dentro das declara√ß√µes (Claims). Lembre-se que esta parte do Token JWT pode ser facilmente decodificada.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

**Linha 42:** O atributo **Expires** √© respons√°vel por inserir a **claim exp (expiration - data e hora da expira√ß√£o)**, preenchida com a data e a hora (incluindo os milissegundos da hora) exata do momento da cria√ß√£o do token, somada **ao tempo limite do token**, no Payload do Token JWT.  Em nosso exemplo, o limite de expira√ß√£o do Token √© de **60 minutos ü°™ 1 hora**.

**Linha 43:**  O atributo **SigningCredentials** √© respons√°vel por armazenar a **assinatura do Token JWT encriptada**. Sem esta chave, como vimos anteriormente, √© imposs√≠vel alterar o conte√∫do do Token, tornando o Token inv√°lido. Este processo √© relativamente simples e pode ser executado pelo M√©todo **SigningCredentials( Chave, Algoritmo)**, da Classe **SigningCredentials**.

A **Chave** ser√° um Objeto da Classe **SymmetricSecurityKey**, que √© uma Classe Abstrata, que representa todas as Chaves geradas usando algoritmo. Para criar a Chave utilizamos o M√©todo Construtor da Classe SymmetricSecurityKey, que possui **1 par√¢metro: a vari√°vel tokenKey.**

O **Algoritmo de Encripta√ß√£o** da assinatura do Token JWT ser√° o **HMAC SHA256 - HS256**, padr√£o para Tokens JWT, definido pela Classe **SecurityAlgorithms**.

> **HMAC SHA256 (HS256)** √© um tipo de algoritmo de hash, com chave, que √© constru√≠do a partir da fun√ß√£o hash **SHA-256** e usado como um c√≥digo de autentica√ß√£o de mensagem baseado em hash (HMAC). 
>
> **HS256** √© um m√©todo de assinatura sim√©trica. Isso significa que a mesma chave secreta √© usada para criar e verificar a pr√≥pria assinatura. O emissor anexa o cabe√ßalho JWT e a carga com a chave secreta e faz o hash do resultado usando SHA256, criando uma assinatura. O destinat√°rio usa suas c√≥pias da chave secreta, cabe√ßalho JWT e carga √∫til da mesma maneira para reproduzir a assinatura, verificando se eles correspondem.

**Linha 45:** Cria o Token JWT utilizando o M√©todo **CreateToken(tokenDescriptor)**, da Classe **JwtSecurityTokenHandler**. Observe que para gerar o Token foi utilizado como par√¢metro do M√©todo o Objeto **tokenDescriptor**, da Classe **SecurityTokenDescriptor**, que cont√©m o Payload e a Assinatura do Token.

O M√©todo **CreateToken(tokenDescriptor)**, ao ser executado, ir√° gerar um Token JWT, semelhante ao da imagem abaixo:

<div align="center"><img src="https://i.imgur.com/KJGpW3x.png" title="source: imgur.com" /></div>

O Token acima, est√° estruturado da seguinte forma:

<div align="center"><img src="https://i.imgur.com/FzmehdM.png" title="source: imgur.com" /></div>

**Linhas 47 a 51:** Preenchemos o Objeto **usuarioLogin** com os dados encontrados no Banco de dados e com o Token JWT, que foi gerado na linha 45.

**Linha 49:** Antes de preencher o atributo **foto**, verificaremos se ele √© nulo. Caso seja, o atributo foto ser√° preenchido com o link da foto padr√£o da API (**FotoDefault**).

**Linha 50:** Observe que no atributo **token** foi realizada uma concatena√ß√£o da palavra **Bearer**, seguida de um espa√ßo em branco e o Token JWT. **Caso n√£o seja inserida a palavra Bearer seguida de um espa√ßo em branco no Token, o Navegador n√£o ir√° reconhecer o Token**.

**Linha 51:** Note que o atributo **senha** foi deixado em branco.

**Linha 53:** O M√©todo **Autenticar(UserLogin usuarioLogin)** retorna o Objeto **usuarioLogin** preenchido e com o Token.

<br />

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://github.com/neoKushan/BCrypt.Net-Core" target="_blank"><b>Documenta√ß√£o: Pacote BCrypt</b></a></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/" target="_blank"><b>Ferramenta: JWT Debugger</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.identitymodel.tokens.jwt.jwtsecuritytokenhandler?view=msal-web-dotnet-latest" target="_blank"><b>Documenta√ß√£o: Classe JwtSecurityTokenHandler</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.text.encoding?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Classe Encoding</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/windows/apps/design/globalizing/use-utf8-code-page" target="_blank"><b>Documenta√ß√£o: Codifica√ß√£o UTF-8</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.identitymodel.tokens.securitytokendescriptor?view=netframework-4.8.1" target="_blank"><b>Documenta√ß√£o: Classe SecurityTokenDescriptor</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.security.claims.claimsidentity?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Classe ClaimsIdentity</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.security.claims.claim?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Classe Claim</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.security.claims.claimtypes?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Classe ClaimTypes</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.identitymodel.tokens.signingcredentials?view=netframework-4.8.1" target="_blank"><b>Documenta√ß√£o: Classe SigningCredentials</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.identitymodel.tokens.symmetricsecuritykey?view=dotnet-plat-ext-7.0" target="_blank"><b>Documenta√ß√£o: Classe SymmetricSecurityKey</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.identitymodel.tokens.securityalgorithms?view=dotnet-plat-ext-7.0" target="_blank"><b>Documenta√ß√£o: Classe SecurityAlgorithms</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/SHA-2" target="_blank"><b>Algoritmo SHA256.</b></div>

<br />

<h2>üë£ Passo 04 - Registrar a Classe AuthService na Classe Program</h2>



Vamos registrar a Classe **AuthService** como um servi√ßo na Classe **Program**. 

1. Abra a Classe **Program**;
2. Localize a linha indicada abaixo:

 <div align="left"><img src="https://i.imgur.com/Qm8xf6t.png" title="source: imgur.com" /></div>

4. Ap√≥s a linha indicada acima, adicione o trecho de c√≥digo abaixo:

```c#
builder.Services.AddTransient<IAuthService, AuthService>();
```

5. A imagem abaixo, mostra como ficar√° o trecho com a nova linha:

 <div align="left"><img src="https://i.imgur.com/2n2nf7m.png" title="source: imgur.com" /></div>

6. Abaixo desta linha que acabamos de adicionar, vamos habilitar a **Valida√ß√£o do Token JWT** em todas as Requisi√ß√µes HTTP, adicionando as linhas abaixo:

```c#
 			// Adicionar a Valida√ß√£o do Token JWT

			builder.Services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddJwtBearer(options =>
            {
                var Key = Encoding.UTF8.GetBytes(Settings.Secret);
                options.SaveToken = true;
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(Key)
                };
            });
```

Vamos analisar o c√≥digo acima:

 <div align="left"><img src="https://i.imgur.com/Deh1rQJ.png" title="source: imgur.com" /></div>

**Linha 54:** Adicionamos o servi√ßo de autentica√ß√£o ao pipeline de execu√ß√£o do ASP.NET, ou seja, habilitamos o servi√ßo de autentica√ß√£o, que ir√° procurar no Cabe√ßalho (header) de todas as requisi√ß√µes HTTP um Token.

**Linha 56:** Estamos informando ao servi√ßo de autentica√ß√£o, que ele deve procurar um Token **Bearer**, no formato **JWT**. **Bearer** significa que o Token ser√° enviado no cabe√ßalho da requisi√ß√£o, na propriedade **Authorization**.

Na imagem abaixo, vemos o Cabe√ßalho de uma Requisi√ß√£o HTTP com o Token Bearer, na propriedade **Authorization**:

<div align="center"><img src="https://i.imgur.com/rvvLw2X.png" title="source: imgur.com" /></div>

**Linha 57:** O Token JWT pode ser gerado de v√°rias formas, inclusive em sites externos, como: Facebook, Twitter, Google e Microsoft. Este processo √© chamado de **Challenge** ou desafiar, onde confrontamos um servidor para que ele
fa√ßa uma autentica√ß√£o e nos retorne o Token. Desta forma, nosso desafio aqui √© dizer para o ASP.NET que estamos utilizando uma autentica√ß√£o interna, ou seja, ela √© gerada neste servidor e vale √∫nica e exclusivamente para este servidor. Por este motivo, precisamos de uma configura√ß√£o adicional **DefaultChallengeScheme**, que  definir√° este processo.

**Linhas 58 a 70:** Os atributos enviados no Payload do Token JWT (usuario, expira√ß√£o, entre outros) est√£o dentro do Token e vamos precisar recuperar estas informa√ß√µes para validar o Token. Entretanto, o Token est√° encriptado e logo para obtermos esses dados, precisamos fazer o processo reverso, para extrair as informa√ß√µes do Token e identificar o Usu√°rio logado. Para efetuarmos esta Opera√ß√£o e validar o Token, vamos definir algumas propriedades.

**Linha 60:** Cria uma vari√°vel do tipo **byte**, chamado **key**, que receber√° o atributo **secret**, da Classe **Settings**, codificado no formato **UTF-8**.

**Linha 61:** Salva os dados de login no **AuthenticationProperties**, que √© uma Collection do tipo **Dictionary**, que armazena as propriedades de Autentica√ß√£o da sess√£o atual.

**Linhas 62 a 69:** Cria um Objeto da Classe **TokenValidationParameters**, que ser√° respons√°vel por definir as regras de valida√ß√£o do Token.

**Linha 64:** Informamos que n√£o iremos validar o Emissor, porque s√≥ existe um √∫nico emissor.

**Linha 65:** Informamos que n√£o iremos validar o Destinat√°rio, porque s√≥ existe um √∫nico destinat√°rio.

**Linha 66:** Informamos validaremos o tempo de vida do Token, ou seja, data e hora de expira√ß√£o.

**Linha 67:** Informamos utilizaremos uma Chave para validar o Token JWT.

**Linha 68:** Informamos atrav√©s do M√©todo **IssuerSigningKey(key)**, qual chave utilizaremos para validar o Token JWT.

7. Para finalizarmos, vamos configurar o ASP.NET para inicializar o servi√ßo todas vezes que a aplica√ß√£o for executada. Localize o trecho de c√≥digo abaixo:

<div align="center"><img src="https://i.imgur.com/rvvLw2X.png" title="source: imgur.com" /></div>

8. Logo abaixo deste trecho, acrescente as linhas abaixo:

```c#
 // Habilitar a Autentica√ß√£o e a Autoriza√ß√£o
app.UseAuthentication();

app.UseAuthorization();
```

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes ao criar a Camada de Seguran√ßa da aplica√ß√£o. Respeitar a ordem que os itens est√£o sendo inseridos na Classe Program √© fundamental para o funcionamento correto da aplica√ß√£o.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />Veja o c√≥digo completo da Classe **Program** abaixo:

```c#

using blogpessoal.Data;
using blogpessoal.Model;
using blogpessoal.Service.Implements;
using blogpessoal.Service;
using blogpessoal.Validator;
using FluentValidation;
using Microsoft.EntityFrameworkCore;
using blogpessoal.Security;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using blogpessoal.Security.Implements;

namespace blogpessoal
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            // Add services to the container.

            // Add Controller Class
            builder.Services.AddControllers()
                .AddNewtonsoftJson(options =>
                {
                    options.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;
                    options.SerializerSettings.NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore;
                }
            );

            // Conex√£o com o Banco de dados
            var connectionString = builder.Configuration.
                    GetConnectionString("DefaultConnection");

            builder.Services.AddDbContext<AppDbContext>(options =>
                options.UseSqlServer(connectionString)
            );

            // Valida√ß√£o das Entidades
            builder.Services.AddTransient<IValidator<Postagem>, PostagemValidator>();
            builder.Services.AddTransient<IValidator<Tema>, TemaValidator>();
            builder.Services.AddTransient<IValidator<User>, UserValidator>();

            // Registrar as Classes e Interfaces Service
            builder.Services.AddScoped<IPostagemService, PostagemService>();
            builder.Services.AddScoped<ITemaService, TemaService>();
            builder.Services.AddScoped<IUserService, UserService>();
            builder.Services.AddTransient<IAuthService, AuthService>();

            // Valida√ß√£o do Token
            builder.Services.AddAuthentication(options =>
            {
                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddJwtBearer(options =>
            {
                var key = Encoding.UTF8.GetBytes(Settings.Secret);
                options.SaveToken = true;
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key)
                };
            });

            // Learn more about configuring Swagger/OpenAPI
            // at https://aka.ms/aspnetcore/swashbuckle

            builder.Services.AddEndpointsApiExplorer();
            builder.Services.AddSwaggerGen();

            // Configura√ß√£o do CORS
            builder.Services.AddCors(options => {
                options.AddPolicy(name: "MyPolicy",
                    policy =>
                    {
                        policy.AllowAnyOrigin()
                        .AllowAnyHeader()
                        .AllowAnyMethod();
                    });
            });

            var app = builder.Build();

            // Criar o Banco de dados e as tabelas Automaticamente
            using (var scope = app.Services.CreateAsyncScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                dbContext.Database.EnsureCreated();

            }

            app.UseDeveloperExceptionPage();

            // Configure the HTTP request pipeline.
            if (app.Environment.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI();
            }

            //Habilitar CORS

            app.UseCors("MyPolicy");

            // Habilitar a Autentica√ß√£o e a Autoriza√ß√£o

            app.UseAuthentication();

            app.UseAuthorization();

            // Habilitar Controller
            app.MapControllers();

            app.Run();
        }
    }
}
```

<br />

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/aspnet/core/security/authentication/?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Autentica√ß√£o</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/aspnet/core/security/authorization/introduction?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Autoriza√ß√£o</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.extensions.dependencyinjection.authenticationservicecollectionextensions.addauthentication?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Classe AddAuthentication</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.authentication.authenticationoptions?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Classe AddAuthentication - Op√ß√µes</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.extensions.dependencyinjection.jwtbearerextensions.addjwtbearer?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: M√©todo AddJwtBearer</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.authentication.jwtbearer.jwtbeareroptions.savetoken?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Propriedade SaveToken</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.identitymodel.tokens.tokenvalidationparameters?view=msal-web-dotnet-latest" target="_blank"><b>Documenta√ß√£o: Classe TokenValidationParameters</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.builder.authappbuilderextensions.useauthentication?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: M√©todo UseAuthentication</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.builder.authorizationappbuilderextensions.useauthorization?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: M√©todo UseAuthorization</b></a></div>

<br />

<h2>üë£ Passo 05 - Atualizar a Classe UserController</h2>



Ap√≥s habilitar a Autentica√ß√£o e a Autoriza√ß√£o, precisamos criar o endpoint de autentica√ß√£o (login), na Classe **UserController**, al√©m de restringir o acesso aos Endpoints da aplica√ß√£o. Vamos come√ßar pelo M√©todo **Autenticar(UserLogin usuarioLogin)**:

1. Abra a Classe **UserController**.
2. Fa√ßa as 3 altera√ß√µes indicadas na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/mfsnfPD.png" title="source: imgur.com" /></div>

Basicamente estamos criando uma Inje√ß√£o de Depend√™ncia para a Classe **AuthService**. N√£o esque√ßa de Importar o Namespace **Security**.

3. Ap√≥s o M√©todo **Atualizar(User usuario)**, implemente o M√©todo **Autenticar(UserLogin usuarioLogin)**, conforme o c√≥digo abaixo:

<div align="center"><img src="https://i.imgur.com/bfTnub9.png" title="source: imgur.com" /></div>

Vamos analisar alguma particularidades do M√©todo acima:

**Linha 94:** Foi inserida a anota√ß√£o **[AllowAnonymous]**, que indica que este endpoint ser√° livre de valida√ß√£o do Token. Se este M√©todo n√£o for liberado de valida√ß√£o do Token, ningu√©m vai conseguir entrar na sua aplica√ß√£o.

**Linha 95:** Foi inserida a anota√ß√£o **[HttpPost("logar")]**, que indica que este endpoint ser√° do tipo **POST**. Caso contr√°rio, a sua aplica√ß√£o n√£o conseguir√° receber atrav√©s do Corpo da Requisi√ß√£o o Objeto da Classe **UserLogin**, contendo o usuario e a senha para autenticar na aplica√ß√£o. Importante refor√ßar que no processo de autentica√ß√£o nenhum dado ser√° persistido no Banco de dados.

Observe na linha 103 que caso o login n√£o seja bem sucedido, ser√° retornado o HTTP Status **UNAUTHORIZED ü°™ 401** para indicar que o usu√°rio n√£o est√° autorizado a acessar o sistema. 

4. Depois de criar o M√©todo  **Autenticar(UserLogin usuarioLogin)**, precisamos configurar os demais M√©todos,  atrav√©s de anota√ß√µes, indicando se ser√£o protegidos ou n√£o. Para os M√©todos n√£o protegidos utilizaremos a anota√ß√£o **[AllowAnonymous]** e para os M√©todos protegidos utilizaremos a anota√ß√£o **[Authorize]**. Caso todos os M√©todos sejam protegidos, adicionaremos a anota√ß√£o na assinatura da Classe ao inv√©s de adicionarmos na assinatura de cada  M√©todo.

Vamos configurar os endpoints da Classe **UserController** para utilizarem a valida√ß√£o do Token JWT. Veja a tabela abaixo:

| M√©todo                   | Protegido? |
| ------------------------ | ---------- |
| **GetAll()**             | Sim        |
| **GetById(long id)**     | Sim        |
| **Create(User usuario)** | N√£o        |
| **Update(User usuario)** | Sim        |

O M√©todo **Create(User usuario)** tamb√©m deve ser liberado de valida√ß√£o porque caso contr√°rio nenhum usu√°rio conseguir√° se cadastrar na sua aplica√ß√£o e efetuar o login posteriormente.

Veja abaixo a implementa√ß√£o final do c√≥digo da Classe **UserController**:


```c#
using blogpessoal.Model;
using blogpessoal.Security;
using blogpessoal.Service;
using FluentValidation;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace blogpessoal.Controllers
{

    [Route("~/usuarios")]
    [ApiController]
    public class UserController : ControllerBase
    {

        private readonly IUserService _userService;
        private readonly IValidator<User> _userValidator;
        private readonly IAuthService _authService;

        public UserController(
            IUserService userService,
            IValidator<User> userValidator,
            IAuthService authService
            )
        {
            _userService = userService;
            _userValidator = userValidator;
            _authService = authService;
        }

        [Authorize]
        [HttpGet("all")]
        public async Task<ActionResult> GetAll()
        {
            return Ok(await _userService.GetAll());
        }

        [Authorize]
        [HttpGet("{id}")]
        public async Task<ActionResult> GetById(long id)
        {
            var Resposta = await _userService.GetById(id);

            if (Resposta is null)
            {
                return NotFound("Usu√°rio n√£o encontrado!");
            }

            return Ok(Resposta);
        }

        [AllowAnonymous]
        [HttpPost("cadastrar")]
        public async Task<ActionResult> Create([FromBody] User usuario)
        {
            var validarUser = await _userValidator.ValidateAsync(usuario);

            if (!validarUser.IsValid)
                return StatusCode(StatusCodes.Status400BadRequest, validarUser);

            var Resposta = await _userService.Create(usuario);

            if (Resposta is null)
                return BadRequest("Usu√°rio j√° cadastrado!");

            return CreatedAtAction(nameof(GetById), new { id = Resposta.Id }, Resposta);
        }

        [Authorize]
        [HttpPut("atualizar")]
        public async Task<ActionResult> Update([FromBody] User usuario)
        {
            if (usuario.Id == 0)
                return BadRequest("O Id do Usu√°rio √© inv√°lido!");
            
            var validarUser = await _userValidator.ValidateAsync(usuario);

            if (!validarUser.IsValid)
                return StatusCode(StatusCodes.Status400BadRequest, validarUser);

            var UserUpdate = await _userService.GetByUsuario(usuario.Usuario);

            if ((UserUpdate is not null) && (UserUpdate.Id != usuario.Id))
                return BadRequest("O Usu√°rio (e-mail) j√° est√° em uso por outro usu√°rio.");

            var Resposta = await _userService.Update(usuario);

            if (Resposta is null)
                return BadRequest("Usu√°rio n√£o encontrado!");

            return Ok(Resposta);
        }

        [AllowAnonymous]
        [HttpPost("logar")]
        public async Task<ActionResult> Autenticar([FromBody] UserLogin usuarioLogin)
        {
            var Resposta = await _authService.Autenticar(usuarioLogin);

            if (Resposta is null)
                return Unauthorized("Usu√°rio e/ou Senha inv√°lidos!");

            return Ok(Resposta);
        }

    }
}
```

<br />

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/aspnet/core/security/authorization/simple?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Autoriza√ß√£o Simples</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/microsoft.aspnetcore.authorization.allowanonymousattribute?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Anota√ß√£o AllowAnonymous</b></a></div>

<div align="left"><img src="https://i.imgur.com/wHTDfQ2.png" title="source: imgur.com" width="4%"/> <a href="https://learn.microsoft.com/pt-br/aspnet/core/security/authorization/limitingidentitybyscheme?view=aspnetcore-7.0" target="_blank"><b>Documenta√ß√£o: Anota√ß√£o Authorize</b></a></div>

<br />

<h2>üë£ Passo 06 - Atualizar a Classe TemaController</h2>



Vamos atualizar a Classe **TemaController**, adicionando a anota√ß√£o **[Authorize]** na assinatura da Classe. Desta forma, vamos proteger todos os endpoints do Recurso Tema. Veja a implementa√ß√£o do c√≥digo abaixo:

```c#
using blogpessoal.Model;
using blogpessoal.Service;
using FluentValidation;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace blogpessoal.Controller
{
    [Authorize]
    [Route("~/temas")]
    [ApiController]
    public class TemaController : ControllerBase
    {

        private readonly ITemaService _temaService;
        private readonly IValidator<Tema> _temaValidator;

        public TemaController(
            ITemaService temaService,
            IValidator<Tema> temaValidator
            )
        {
            _temaService = temaService;
            _temaValidator = temaValidator;
        }

        [HttpGet]
        public async Task<ActionResult> GetAll()
        {
            return Ok(await _temaService.GetAll());
        }

        [HttpGet("{id}")]
        public async Task<ActionResult> GetById(long id)
        {
            var Resposta = await _temaService.GetById(id);

            if (Resposta is null)
            {
                return NotFound("Tema n√£o encontrado!");
            }

            return Ok(Resposta);
        }

        [HttpGet("descricao/{descricao}")]
        public async Task<ActionResult> GetByDescricao(string descricao)
        {
            return Ok(await _temaService.GetByDescricao(descricao));
        }

        [HttpPost]
        public async Task<ActionResult> Create([FromBody] Tema tema)
        {
            var validarTema = await _temaValidator.ValidateAsync(tema);

            if (!validarTema.IsValid)
                return StatusCode(StatusCodes.Status400BadRequest, validarTema);

            var Resposta = await _temaService.Create(tema);
            return CreatedAtAction(nameof(GetById), new { id = Resposta.Id }, Resposta);
        }

        [HttpPut]
        public async Task<ActionResult> Update([FromBody] Tema tema)
        {
            if (tema.Id == 0)
                return BadRequest("O Id do Tema √© inv√°lido!");

            var validarTema = await _temaValidator.ValidateAsync(tema);

            if (!validarTema.IsValid)
                return StatusCode(StatusCodes.Status400BadRequest, validarTema);

            var Resposta = await _temaService.Update(tema);

            if (Resposta is null)
                return NotFound("Tema n√£o encontrado!");

            return Ok(Resposta);
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id)
        {
            var BuscaTema = await _temaService.GetById(id);

            if (BuscaTema is null)
                return NotFound();

            await _temaService.Delete(BuscaTema);

            return NoContent();

        }

    }
}
```

<br />

<h2>üë£ Passo 07 - Atualizar a Classe PostagemController</h2>



Vamos atualizar a Classe **PostagemController**, adicionando a anota√ß√£o **[Authorize]** na assinatura da Classe. Desta forma, vamos proteger todos os endpoints do Recurso Postagem. Veja a implementa√ß√£o do c√≥digo abaixo:

```c#
using blogpessoal.Model;
using blogpessoal.Service;
using FluentValidation;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace blogpessoal.Controller
{
    [Authorize]
    [Route("~/postagens")]
    [ApiController]
    public class PostagemController : ControllerBase
    {
        private readonly IPostagemService _postagemService;
        private readonly IValidator<Postagem> _postagemValidator;

        public PostagemController(
            IPostagemService postagemService,
            IValidator<Postagem> postagemValidator
            )
        {
            _postagemService = postagemService;
            _postagemValidator = postagemValidator;
        }

        [HttpGet]
        public async Task<ActionResult> GetAll()
        {
            return Ok(await _postagemService.GetAll());
        }

        [HttpGet("{id}")]
        public async Task<ActionResult> GetById(long id)
        {
            var Resposta = await _postagemService.GetById(id);

            if (Resposta is null)
            {
                return NotFound("Postagem n√£o encontrada!");
            }

            return Ok(Resposta);
        }

        [HttpGet("titulo/{titulo}")]
        public async Task<ActionResult> GetByTitulo(string titulo)
        {
            return Ok(await _postagemService.GetByTitulo(titulo));
        }

        [HttpPost]
        public async Task<ActionResult> Create([FromBody] Postagem postagem)
        {
            var validarPostagem = await _postagemValidator.ValidateAsync(postagem);

            if (!validarPostagem.IsValid)
                return StatusCode(StatusCodes.Status400BadRequest, validarPostagem);

            var Resposta = await _postagemService.Create(postagem);

            if (Resposta is null)
                return BadRequest("Tema n√£o encontrado!");

            return CreatedAtAction(nameof(GetById), new { id = postagem.Id }, postagem);
        }

        [HttpPut]
        public async Task<ActionResult> Update([FromBody] Postagem postagem)
        {
            if (postagem.Id == 0)
                return BadRequest("Id da Postagem √© inv√°lido!");

            var validarPostagem = await _postagemValidator.ValidateAsync(postagem);

            if (!validarPostagem.IsValid)
                return StatusCode(StatusCodes.Status400BadRequest, validarPostagem);

            var Resposta = await _postagemService.Update(postagem);

            if (Resposta is null)
                return NotFound("Postagem e/ou Tema n√£o encontrados!");

            return Ok(Resposta);

        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id)
        {
            var BuscaPostagem = await _postagemService.GetById(id);

            if (BuscaPostagem is null)
                return NotFound("Postagem n√£o encontrada!");

            await _postagemService.Delete(BuscaPostagem);

            return NoContent();

        }

    }

}
```

<br />

<h2>üë£ Passo 08 - Executar o projeto</h2>



Para executarmos o Projeto, clique no bot√£o <img src="https://i.imgur.com/gPnfOVk.png" title="source: imgur.com" width="8%"/>**Run http**, na **Barra de Ferramentas Principal** (indicado em verde na imagem):

![Imagem 30](https://i.imgur.com/Ya4O50P.png)

<br />

<h2>üë£ Passo 09 - Testar o M√©todo Autenticar no Insomnia</h2>



Vamos criar no Insomnia, **dentro da pasta usuario**, a requisi√ß√£o Autenticar Usu√°rio:

| <img src="https://i.imgur.com/RfjtOFi.png" title="source: imgur.com" width="100px"/> | <div align="left"> **DICA:** *Caso voc√™ tenha alguma d√∫vida sobre como criar as Requisi√ß√µes, consulte a Documenta√ß√£o do Recurso Postagem.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<h3>9.1. Criando a  Requisi√ß√£o - Autenticar Usu√°rio (Login)</h3>



1. Clique com o bot√£o direito do mouse sobre a **Pasta Usuario** para abrir o menu e clique na op√ß√£o **New HTTP Request**.

2. Ser√° criada uma nova Requisi√ß√£o (New Request) dentro da pasta **Usuario**.

3. D√™ um duplo clique sobre a nova requisi√ß√£o (**New Request**), informe o nome da requisi√ß√£o (indicado na imagem abaixo na cor amarela) e pressione a tecla **enter** do seu teclado.

<div align="center"><img src="https://i.imgur.com/sVVW1sF.png" title="source: imgur.com" /></div>

4. Selecione o M√©todo HTTP que ser√° utilizado (**POST**) na requisi√ß√£o, indicado na imagem abaixo na cor verde. 

<div align="center"><img src="https://i.imgur.com/TLBY2tJ.png" title="source: imgur.com" /></div>

5. No item **Body**, vamos alterar para **JSON**, como mostra a imagem abaixo. Desta forma poderemos enviar os dados do Objeto **UsuarioLogin** no Corpo da Requisi√ß√£o, no formato JSON.

<div align="center"><img src="https://i.imgur.com/PxOpzFd.png" title="source: imgur.com" /></div>

6. Observe que o item **Body** ser√° renomeado para **JSON**, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/8hDNIbh.png" title="source: imgur.com" /></div>

7. Configure a requisi√ß√£o conforme a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/Wxc3wyG.png" title="source: imgur.com" /></div>

8. Observe que no JSON estamos informando apenas o usu√°rio e a senha, porqu√™ s√£o os dois √∫nicos Atributos da Classe **UsuarioLogin**. Se o login for efetuado com sucesso, ser√° retornado um JSON no Corpo da Resposta, como vemos na figura abaixo:

<div align="center"><img src="https://i.imgur.com/Z0lqrkF.png" title="source: imgur.com" /></div>

9. Observe que o Token foi gerado e enviado na resposta. Copie o Token da  resposta porqu√™ vamos precisar dele nas pr√≥ximas requisi√ß√µes.

<div align="center"><img src="https://i.imgur.com/gcrxQIE.png" title="source: imgur.com" /></div>

10. Caso o login falhe, voc√™ receber√° o **status 401 (Unauthorized)**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/n1zpjG4.png" title="source: imgur.com" /></div>

<br />

| <img src="https://i.imgur.com/L338M2G.png" title="source: imgur.com" width="80px"/> | **DESAFIO:** *Experimente executar as outras Requisi√ß√µes, que foram criadas anteriormente no Insomnia. Elas funcionaram?* |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<h3>9.2. Adicionar o Token JWT na Requisi√ß√£o Consultar todos os Usuarios</h3>



Se voc√™ fez o teste no Desafio acima, deve ter notado que todas Requisi√ß√µes, **exceto Cadastrar Usu√°rio** retornaram o HTTP Status **UNAUTHORIZED ü°™ 401** (Acesso n√£o autorizado!), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/863LvHu.png" title="source: imgur.com" /></div>

A explica√ß√£o √© simples: **Todos os M√©todos protegidos precisam receber um Token JWT v√°lido para autorizar a Requisi√ß√£o**. Vamos configurar a Requisi√ß√£o Consultar todos os Usu√°rios para enviar o Token no cabe√ßalho da Requisi√ß√£o. 

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha a Aten√ß√£o aos Detalhes. Os passos que ser√£o apresentados a seguir voc√™ dever√° fazer em todas as Requisi√ß√µes, de todos os Recursos, exceto Autenticar Usu√°rio e Cadastrar Usu√°rio.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="120px"/> | <div align="left"> **MUITA ATEN√á√ÉO!** *Lembre-se que o Token JWT permanece v√°lido por apenas 1 hora. Depois desta 1 hora, voc√™ precisar√° logar, obter um novo Token JWT e trocar  o Token em todas as Requisi√ß√µes do Insomnia, exceto nas Requisi√ß√µes Autenticar Usu√°rio e Cadastrar Usu√°rio.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |


1. Vamos abrir a Requisi√ß√£o Consultar todos os Usu√°rios.


<div align="center"><img src="https://i.imgur.com/Veedyux.png" title="source: imgur.com" /></div>

4. Clique na Guia **Header**.

<div align="center"><img src="https://i.imgur.com/VYYcCfH.png" title="source: imgur.com" /></div>

5.  No Campo **New header**, adicione a propriedade **Authorization**.

<div align="center"><img src="https://i.imgur.com/lKJ8e5G.png" title="source: imgur.com" /></div>

6.  Volte na Requisi√ß√£o **Autenticar Usu√°rio**, **selecione o Token inteiro, exceto as aspas**, como mostra a imagem abaixo e copie.

<div align="center"><img src="https://i.imgur.com/OqZXGxz.png" title="source: imgur.com" /></div>

7. No campo **Value** da propriedade **Authorization**, cole o **Token** que voc√™ copiou na Requisi√ß√£o **Autenticar Usu√°rio**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/ZRwVxmZ.png" title="source: imgur.com" /></div>

8. Teste a Requisi√ß√£o novamente. Agora ela deve estar funcionando!
8. Quando o Token expirar, voc√™ receber√° o **status 401 (Unauthorized)**, como mostra a figura abaixo:

<div align="center"><img src="https://i.imgur.com/863LvHu.png" title="source: imgur.com" /></div>

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="120px"/> | <div align="left"> **MUITA ATEN√á√ÉO!** **N√£o esque√ßa de adicionar o Token JWT em todas as Requisi√ß√µes, de todos os Recursos, exceto Autenticar Usu√°rio e Cadastrar Usu√°rio**.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="120px"/> | <div align="left"> ATEN√á√ÉO: No Frontend, independente de ser implementado no Angular ou no React, a passagem do Token ser√° automatizada.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="https://github.com/rafaelq80/backend_blogpessoal_aspnet_v7/tree/15_security" target="_blank"><b>C√≥digo fonte do projeto</b></a></div>

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
